<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />

<title>Emacs Library Reference</title>
<link rel="stylesheet" href="styles.css" />
</head>
<body>
<div class="contents">
<a name="top"></a> 

<h1><a name="libraryreference"></a>Emacs Library Reference</h1>


<h2><a name="abbrev"></a>ABBREV, Extended Abbreviation Support</h2>

<p>The ABBREV library provides useful functions that allow you to manipulate abbreviations. To access these functions, you must load ABBREV using <kbd>ESC-x execute-mlisp-file</kbd>.</p>

<p>The functions defined in the ABBREV library and their key bindings are as follows:</p>


<p><b>^X-G (define-global-abbrev-in-buffer)</b></p>

<blockquote>
<p>Takes the word to the left of dot and defines it as a global abbreviation. You are prompted for the expansion in the Mini-buffer.</p>
</blockquote>


<p><b>^X-L (define-local-abbrev-in-buffer)</b></p>

<blockquote>
<p>Takes the word to the left of dot and defines it as an abbreviation in the current buffer's local abbreviation table. You are prompted for the abbreviation's expansion in the Mini-buffer.</p>
</blockquote>


<p><b>(list-local-abbrevs)</b></p>

<blockquote>
<p>Displays a buffer called Abbrev list and fills it with the abbreviations and their expansions in effect for the current buffer.</p>
</blockquote>


<p><b>^X-W (edit-local-abbrevs)</b></p>

<blockquote>
<p>Displays a buffer called Abbrev list, fills it with the abbreviations and their expansions in effect for the current buffer and then enters a recursive edit so that you can edit these definitions. When the recursive edit is exited, the buffer is used to define the new abbreviations.</p>
</blockquote>


<p><b>(list-all-abbrevs)</b></p>

<blockquote>
<p>Displays a buffer called Abbrev list and fills it with the abbreviations and expansions currently defined in Emacs.</p>
</blockquote>


<p><b>(edit-all-abbrevs)</b></p>

<blockquote>
<p>Displays a buffer called Abbrev list, fills it with all the abbreviations defined in the current Emacs, and then enters a recursive edit to let you alter these abbreviations. When you exit the recursive edit, the modified buffer contents are used to define the abbreviations.</p>
</blockquote>


<p><b>^X-R (define-global-abbrev-for-region)</b></p>

<blockquote>
<p>Uses the region as an expansion and prompts you for an abbreviation. The abbreviation is defined in the global abbreviation table.</p>
</blockquote>


<p><b>^X-S (define-local-abbrev-for-region)</b></p>

<blockquote>
<p>Uses the region as an expansion and prompts you for an abbreviation. The abbreviation is defined in the current buffer's local abbreviation table.</p>

<p>The AREA package defines two functions that allow you to define a box and then remove the text from that box leaving the text not included in the box undisturbed. The removed text is stored in a buffer called Area. This text may be inserted later at some other location.</p>

<p>The AREA functions and key bindings are:</p>
</blockquote>


<p><b>ESC-w (delete-area)</b></p>

<blockquote>
<p>Deletes a vertically-bounded area, storing the deleted area in a buffer named Area.</p>
</blockquote>


<p><b>ESC-y (insert-area)</b></p>

<blockquote>
<p>Inserts the contents of the Area buffer into the current buffer at dot.</p>

<p>The AREA library has been superceded by the RECTANGULAR library, but it is still supplied with Emacs for compatibility with existing MLisp code. For details on the RECTANGULAR library, see <a href="#rectangular">RECTANGULAR, Rectangular Cut and Paste</a></p>
</blockquote>


<h2><a name="buff"></a>BUFF, One Line Buffer Listing</h2>

<blockquote>
<p>This library defines the single function one-line-buffer-list. This function displays the names of all of the buffers in Emacs in the mode line. If more that one line's worth of buffers exist, each line of names is displayed and a character input to display the next line. The default binding for the one-line-buffer-list function is <kbd>^X-^B</kbd>.</p>

<p>Some buffers in the list may be preceded by a single character. The various characters and their meanings are:</p>

<table>
<tr>
<td><strong>*</strong></td>
<td>Indicates that the buffer has been modified since it was last written to disk</td>
</tr>

<tr>
<td><strong>#</strong></td>
<td>Indicates that the buffer is a scratch buffer.</td>
</tr>

<tr>
<td><strong>@</strong></td>
<td>Indicates that the buffer is empty.</td>
</tr>
</table>
</blockquote>


<h2><a name="centerlin"></a>CENTERLIN, Line Centering</h2>

<p>The CENTERLIN library package defines the single function center-line which can be used to centre the current line between the margins as defined by left-margin and right-margin.</p>

<p>There is no default binding for the center-line function.</p>


<h2><a name="dabbrev"></a>DABBREV, Dynamic Abbreviation Expansion</h2>


<p>The DABBREV library defines the dabbrev function. The dabbrev function takes the word that the cursor is positioned in and looks through the buffer for a word for which the current word is a prefix. If a match is found, the current word is expanded into the full word.</p>

<p>For example, if you have already typed the word FOOBAR into the buffer, you can then type the subword FOO, then execute the dabbrev function and FOO will be expanded to FOOBAR.</p>


<p><b>dabbrev-expand-whole-word 0</b></p>

<blockquote>
<p>This variable changes the way dabbrev works when you start dabbrev in the middle of a word.
Either dabbrev uses the whole of the word as the prefix to expand or dabbrev uses the beginning of
the word and deletes the end of the word.</p>

</blockquote>


<p><b>^W (dabbrev)</b></p>

<blockquote>
<p>dabbrev.</p>
</blockquote>


<h2><a name="dent"></a>DENT, Region Indentation</h2>

<p>The DENT library defines the functions indent-region and undent-region. indent-region indents the currently selected region by logical-tab-size characters. If provided with a prefix argument, it performs the indentation the specified numbers of times. undent-region undents the current region.</p>


<h2><a name="edtsim"></a>EDTSIM, EDT Simulation</h2>

<p>The EDTSIM package defines functions which emulate the EDT text editor found on the OpenVMS operating system from Digital Equipment Corporation.</p>

<p>When you load the EDTSIM library (using <kbd>ESC-x execute-mlisp-file edtsim</kbd>), the numeric keypad keys are re-bound to perform the same actions as they would in the real EDT editor. The major mode string in the mode line is modified to indicate that EDT simulation is loaded.</p>

<p>The following list contains all of the implemented EDT commands with a simple description of what each command does.</p>

<table cellspacing="10">
<tr>
<td valign="top" width="60%">Introduce a command repetition count.</td>
<td><span class="key">GOLD-digits</span></td>
</tr>

<tr>
<td valign="top" width="60%">The GOLD key.</td>
<td><span class="key">PF1</span></td>
</tr>

<tr>
<td valign="top" width="60%">Give help and also, when a command is requested, cause Emacs name completion. The help text is obtained from the EDT help library, and re-formatted so that it can be displayed from within Emacs.</td>
<td><span class="key">PF2 (HELP)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Find the next occurrence of the current search string.</td>
<td><span class="key">PF3 (FNDNXT)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Delete to the end of the current line and delete the line terminator.</td>
<td><span class="key">PF4 (DEL-L)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Move to the next line in the current direction.</td>
<td><span class="key">KP0 (LINE)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Move to the next word in the current direction.</td>
<td><span class="key">KP1 (WORD)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Move to the end of the current line.</td>
<td><span class="key">KP2 (EOL)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Moves to the next character in the current direction.</td>
<td><span class="key">KP3 (CHAR)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Change the current direction to forwards. This key may also to used to terminate a search string.</td>
<td><span class="key">KP4 (ADVANCE)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Change the current direction to backwards. This key may also be used to terminate a search string.</td>
<td><span class="key">KP5 (BACKUP)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Cut the select region and put it in the paste buffer.</td>
<td><span class="key">KP6 (CUT)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Move to the next page in the current direction.</td>
<td><span class="key">KP7 (PAGE)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Scroll the window by two thirds and moves dot to the selected line.</td>
<td><span class="key">KP8 (SECT)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Set the start of the select region to the current cursor position.</td>
<td><span class="key">KP. (SELECT)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Delete the character following the current cursor position.</td>
<td><span class="key">KP, (DEL-C)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Delete the word following the current cursor position.</td>
<td><span class="key">KP-- (DEL-W)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Insert a line terminator after the current cursor position.</td>
<td><span class="key">GOLD-KP0 (OPEN LINE)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Invert the case of the current character or select region.</td>
<td><span class="key">GOLD-KP1 (CHGCASE)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Delete the text from dot to the end of the current line.</td>
<td><span class="key">GOLD-KP2 (DEL-EOL)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Insert a character into the buffer. The character inserted has the numeric value specified by the command's prefix argument.</td>
<td><span class="key">GOLD-KP3 (SPECINS)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Move the current cursor position to the bottom of the current buffer.</td>
<td><span class="key">GOLD-KP4 (BOTTOM)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Move the current cursor position to the top of the current buffer.</td>
<td><span class="key">GOLD-KP5 (TOP)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Insert the contents of the paste buffer at the current cursor position.</td>
<td><span class="key">GOLD-KP6 (PASTE)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Go to the Emacs command line.</td>
<td><span class="key">GOLD-KP7 (CMD)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Replace a string throughout the rest of the buffer.</td>
<td><span class="key">GOLD-KP9 (REPLACE)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Unset the start of the select region.</td>
<td><span class="key">GOLD-KP. (RESET)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Paste in the last character deleted.</td>
<td><span class="key">GOLD-KP, (UND-C)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Paste in the last word deleted.</td>
<td><span class="key">GOLD-KP- (UND-W)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Search for an occurrence of a string.</td>
<td><span class="key">GOLD-PF3 (FIND)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Paste in the last line deleted.</td>
<td><span class="key">GOLD-PF4 (UND-L)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Move the cursor up one line.</td>
<td><span class="key">Up-arrow (UP)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Move the cursor down one line.</td>
<td><span class="key">Down-arrow (DOWN)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Move the cursor left one character.</td>
<td><span class="key">left-arrow (left)</span></td>
</tr>

<tr>
<td valign="top" width="60%">Move the cursor right one character.</td>
<td><span class="key">Right-arrow (RIGHT)</span></td>
</tr>
</table>


<h2><a name="electricc"></a>ELECTRICC, A Mode for Writing C Programs</h2>

<p>The ELECTRICC library defines functions for Electric C Mode, a major mode for writing C programs. Electric C Mode is an alternative library to the C Mode library described in the Barry's Emacs Programmer's Guide.</p>

<p>Electric C Mode performs a number of useful functions for the C programmer, including:</p>

<ul>
<li>Balancing of parentheses</li>
<li>Proper indentation of compound statement blocks</li>
<li>Comment handling</li>
<li>Highlight white space issues if <a href="#white-space-mini-mode">white-space-mini-mode</a> has been loaded and configured.</li>
</ul>


<h2><a name="flasher"></a>FLASHER, Parenthesis Balancing</h2>

<blockquote>
<p>The FLASHER library defines the single function paren-flashwhich can be used to cause parenthesis balancing The function paren-flash should be bound to the closing version of the brackets that are to be balanced.</p>

<p>Two buffer-specific variables are used to provide input parameters to the functions:</p>
</blockquote>


<p><b>paren-flash-wait</b></p>

<blockquote>
<p>A numeric variable used to control the maximum length of time the cursor stays over a matching parenthesis. The value is specified in tenths of a second. The default value is 10 (1 second).</p>
</blockquote>


<p><b>paren-flash-message</b></p>

<blockquote>
<p>A boolean variable used to control the displaying of the error message when no matching bracket is found. If true, an error message is displayed; otherwise, the fact that the bracket is non-matching is ignored.</p>
</blockquote>


<h2><a name="globdel"></a>GLOBDEL, Global Deletion Of Lines</h2>

<blockquote>
<p>The GLOBDEL library provides the facility to nominate a set of lines by a search string, and then delete all the nominated lines. The library defines two functions:</p>
</blockquote>


<p><b>(global-delete-lines)</b></p>

<blockquote>
<p>Prompts for an ordinary search string, and deletes all lines containing that string.</p>
</blockquote>


<p><b>(re-global-delete-lines)</b></p>

<blockquote>
<p>Prompts for a regular expression search string, and deletes all lines containing the regular expression.</p>

<p>Both functions indicate the total number of lines deleted.</p>
</blockquote>


<h2><a name="goto"></a>GOTO, Goto Line/Page/Percent</h2>

<blockquote>
<p>The GOTO library defines functions that move dot directly to a specified line, page, or percentage of the current buffer. The functions defined are:</p>
</blockquote>


<p><b>(goto-line)</b></p>

<blockquote>
<p>Moves dot to the beginning of the specified line. If a prefix argument is provided, use that as the line number to find. The first line in the buffer is line number 1.</p>
</blockquote>


<p><b>(adjust-line-number)</b></p>

<blockquote>
<p>Makes the current line line number 1 so that goto-line starts counting from the current line rather than the beginning of the file.</p>
</blockquote>


<p><b>(goto-page)</b></p>

<blockquote>
<p>Moves dot to the beginning of the specified page. If a prefix argument is provided, use that as the page number to find.</p>
</blockquote>


<p><b>(goto-percent)</b></p>

<blockquote>
<p>Moves dot to the percentage position of the file indicated. If a prefix argument is provided, use that as the percentage position to find. The beginning of the file is percentage position 0. The end of the file is percentage position 100.</p>
</blockquote>


<h2><a name="html"></a>HTMLMODE, HTML mode</h2>

<blockquote>
<p>The HTMLMODE library defines the HTML editing mode, HTML-mode.</p>

<p>HTML-mode provides syntax colouring for HTML code. HTML version 3.2 is fully supported, however not all of HTML 4.0 is syntax coloured.</p>
</blockquote>


<p><b>ESC-c (HTML-view-buffer)</b></p>

<blockquote>
<p>Save the HTML document and then view the HTML document using the default Web browser.</p>
</blockquote>


<p><b>(HTML-mode)</b></p>

<blockquote>
<p>Start HTML-mode for the current buffer.</p>
</blockquote>


<h2><a name="incsearch"></a>INCSEARCH, Incremental Searching</h2>

<blockquote>
<p>When you execute the normal Emacs search commands, you are prompted for the search string in the Mini-buffer. You type in the entire search string, press Return, and Emacs searches for the specified string. The INCSEARCH library defines functions which implement a different style of searching called incremental searching.</p>

<p>Incremental searches begin searching before you have finished typing the search string. As you type in the search string, Emacs moves the cursor to where the string would be found. When you have typed enough characters to identify the place you want, you can stop. Depending on what you will do next, you may or may not need to terminate the search explicitly with an RETURN.</p>

<p>Incremental searching is enabled by loading the INCSEARCH package. This package replaces the existing search commands with the following commands:</p>
</blockquote>


<p><b>^F (incremental-search)</b></p>

<blockquote>
<p>Performs a forwards incremental search.</p>
</blockquote>


<p><b>^R (reverse-incremental-search)</b></p>

<blockquote>
<p>Performs a reverse incremental search.</p>
</blockquote>


<p><b>inc-search-use-region 0</b></p>

<blockquote>
<p>Set variable inc-search-use-region to 1 to prevent incremental search from using the hilighted text 
as the default search string.</p>
</blockquote>



<p>The ^F command initiates a forwards incremental search. It reads in characters and positions the cursor at the first occurrence of the characters that you have typed. If you type ^F-F, the cursor moves right after the first F. Type an O, and the cursor moves to the first FO. After another O, the cursor is moved to the first occurrence of FOO. At the same time, the text FOO is echoed at the bottom of the screen.</p>

<p>If you type a incorrect character, you can rub it out. After the FOO, typing a Delete makes the last O disappear from the bottom of the screen, leaving only FO. The cursor moves back to the first occurrence of FO. If you delete the next O and the F, the cursor moves back to where you started the search.</p>

<p>When you are satisfied with the place you have reached, you can type a RETURN, which stops the search, leaving the cursor where the search brought it. Also, any command not meaningful in incremental searches stops the searching and is then executed. Thus, typing HOME would exit the search and then move to the beginning of the line. RETURN is necessary only if the next command you want to type is a printing character, Delete, RETURN, ^Q, or another search command, since those are the characters that have special meanings inside the search.</p>

<p>Sometimes you may search for FOO and find it, but not the one you expected to find. Type another ^F and the cursor will find the next FOO. This can be done any number of times. If you overshoot, you can rub out the unwanted ^F commands and the cursor will move back to the previous occurrences of the string.</p>

<p>If your string is not found at all, the message Failing I-Search is displayed in the Mini-buffer. The cursor is placed where Emacs found as much of your string as was possible. For example, if you search for FOOT, and there is no FOOT, you might see the cursor after the FOO (if the text FOO exists). At this point there are several things you can do. If your string was mis-typed, you can rub some of it out and correct it. If you like the place you have found, you can type a RETURN or some other Emacs command to accept what the search found.</p>

<p>The ^R command starts a reverse incremental search. This works in exactly the same way as the forward incremental search command, but in the opposite direction.</p>

<p>
If you highlighted some text in the buffer and then start incremental search the text is used as the default string to search for.
</p>
<p>For example hightlight FOO in the buffer, type ^F to start incremental search.
 Notice that the prompt is now "forward I-search [FOO]: " showing that FOO is the default string to search for.
 Type ^F again to find the next FOO.
</p>


<p>
While incremental search is active the default key bindings are:
</p>
<table>
<caption>Incremental search key bindings</caption>

<tr>
<th>Binding</th>
<th>Function</th>
<th>Binding</th>
<th>Function</th>
</tr>

<tr>
<td><span class="key">^F</span></td>
<td>Search forward</td>
<td><span class="key">^R</span></td>
<td>search reverse</td>
</tr>

<tr>
<td><span class="key">^G</span></td>
<td>Abort search and go back to where we started</td>
<td><span class="key">Return</span></td>
<td>Exits incremental search here</td>
</tr>

<tr>
<td><span class="key">^P</span></td>
<td>prompt you for a string to replace what the search has matched so far</td>
<td><span class="key">^Q</span></td>
<td>Quote next character, allows you to search for special characters.</td>
</tr>


<tr>
<td><span class="key">^V</span></td>
<td>Paste the clipboard contents into the search string.</td>
<td><span class="key">^L</span></td>
<td>enter a recursive edit level. Continue searching on exiting the recursive edit</td>
</tr>

<tr>
<td><span class="key">F1</span></td>
<td>Display incremental search help.</td>
<td><span class="key">^_</span></td>
<td>Display incremental search help.</td>
</tr>

</table>



<h2><a name="killer"></a>KILLER, A Kill Ring System</h2>

<p>The KILLER library provides the ability to keep a history of killed objects, and to define a killed object as any combination of successive kill commands. The killed objects are stored in a kill ring and can be retrieved at any time.</p>

<p>The KILLER text deletion functions replace the normal Emacs text deletion commands with versions that delete text and store it in the appropiate place in the kill ring. The kill ring functions and default key bindings are:</p>


<p><b>ESC-. (kr-set-mark)</b></p>

<blockquote>
<p>Sets the mark with reverse-video highlighting enabled.</p>
</blockquote>


<p><b>^X-. (kr-toggle-highlight)</b></p>

<blockquote>
<p>Toggles the highlight setting.</p>
</blockquote>


<p><b>ESC-d (kr-kill-forward-word)</b></p>

<blockquote>
<p>Deletes the next word and inserts it into the kill ring.</p>
</blockquote>


<p><b>ESC-Delete (kr-kill-bacward-word)</b></p>

<blockquote>
<p>Deletes the previous word and inserts it in the kill ring.</p>
</blockquote>


<p><b>^W (kr-kill-region)</b></p>

<blockquote>
<p>Deletes the region and inserts it into the kill ring.</p>
</blockquote>


<p><b>^K (kr-kill-forward-line)</b></p>

<blockquote>
<p>Deletes the current line from dot to the end-of-line and inserts the deleted text into the kill ring.</p>
</blockquote>


<p><b>ESC-k (kr-kill-backward-line)</b></p>

<blockquote>
<p>Deletes the current line from dot to the beginning of the line and inserts the deleted text into the kill ring.</p>
</blockquote>


<p><b>^Y (kr-yank)</b></p>

<blockquote>
<p>Yanks the text from the current buffer in the kill ring, placing the yanked text into the current buffer at dot and leaving the region around the yanked text.</p>
</blockquote>


<p><b>ESC-y (kr-more-yank)</b></p>

<blockquote>
<p>If the text yanked by <kbd>^Y</kbd>. is not the text you want, use <kbd>ESC-y</kbd> to yank text from other buffers in the kill ring. Successive <kbd>ESC-y</kbd>s will yank text from successive buffers in the kill ring. <kbd>ESC-y</kbd> only works after <kbd>^Y</kbd>.</p>

<p>You can change these bindings by making a copy of the KILLER.KEY file, modifying it with your own bindings, and saving the modified file in your EMACS_PATH. kr-max-buf</p>

<p>The default size of the kill ring is 10 buffers. The size of the kill ring is controlled by the kr-max-buf variable which is defined in KILLER.KEY. If you want to change the size of the kill ring, make a private copy of the KILLER.KEY file as described above and change the setting of the kr-max-buf variable.</p>
</blockquote>


<h2><a name="latexmode"></a>LATEXMODE, A Major Mode for writing LaTeX Documents</h2>

<p>The LATEXMODE library implements the LaTeX Mode major mode which can be used to help write documents with the LaTeX document preparation system.</p>

<p>LaTeX Mode works in the same way as the standard Emacs language modes C Mode and Bliss Mode by providing expansion of templates for LaTeXreserved words. LaTeX Mode also defines comment handling and parenthesis balancing.</p>

<p>See the Barry's Emacs Programmer's Guide for details of how to use the Emacs language modes.</p>


<h2><a name="makebox"></a>MAKEBOX, Drawing Boxes Around Text</h2>

<p>The MAKEBOX library can be used to draw rectangular boxes around text. It relies on functions defined in the RECTANGULAR library, so you must first load the RECTANGULAR library before loading MAKEBOX. See <a href="#rectangular">RECTANGULAR, Rectangular Cut and Paste</a> for a description of the RECTANGULAR library.</p>

<p>The library defines the make-box function. To draw a box around text with make-box:</p>

<p>&#183; Select one corner of the box using rectangular-select (which is bound to GOLD-Select by default).</p>

<p>&#183; Move to the diagonally opposite corner of the box.</p>

<p>&#183; Execute the make-box function.</p>

<blockquote>
<p>By default, make-box will use the +, -- and | characters to draw boxes.
You can override these default values by setting the following variables:</p>
</blockquote>


<p><b>makebox-h-symbol</b></p>

<blockquote>
<p>Contains the character that make-box uses to draw horizontal lines.</p>
</blockquote>


<p><b>makebox-v-symbol</b></p>

<blockquote>
<p>Contains the character that make-box uses to draw vertical lines.</p>
</blockquote>


<p><b>makebox-corners</b></p>

<blockquote>
<p>Contains the character that make-box uses to draw corners.</p>

<p>The following example shows how to define your own drawing variables. Note that the MAKEBOX library must be loaded before setting the values of the drawing variables.</p>

<p>(execute-mlisp-file "makebox")</p>

<p>(setq makebox-h-symbol "=")</p>

<p>(setq makebox-v-symbol "!")</p>

<p>(setq makebox-corners "#")</p>

<p>The following convenience functions are defined to set the drawing variables:</p>
</blockquote>


<p><b>makebox-use-lines</b></p>

<blockquote>
<p>Sets the make-box drawing variables to the default line-drawing set.</p>
</blockquote>


<p><b>makebox-use-stars</b></p>

<blockquote>
<p>Sets all the make-box drawing variables to *.</p>
</blockquote>


<h2><a name="minibuf"></a>MINIBUF, Writing and Executing Small MLisp Programs</h2>

<p>The MINIBUF library provides a better interface for the execution simple MLisp programs than the execute-mlisp-line function. When loaded, MINIBUF rebinds <kbd>ESC-ESC</kbd> so that instead of collecting its arguments in the Mini-buffer at the bottom of the screen, it pops up a small buffer called minibuffer to collect the MLisp code. Lisp Mode is in effect in this buffer so that MLisp name expansion can be used.</p>

<p>When you are satisfied that the MLisp in the minibuffer is correct, you can execute it with the command <kbd>ESC-ESC</kbd>. Subsequent uses of <kbd>ESC-ESC</kbd> will re-display the minibuffer containing the last program executed; you can re-execute the same code with <kbd>ESC-ESC</kbd>, or you can edit the code first before executing it with <kbd>ESC-ESC</kbd>.</p>


<h2><a name="minibufrecall"></a>MINIBUF-RECALL, Command Recall in the Mini-buffer</h2>

<p>The MINIBUF-RECALL library provides the ability to recall and edit commands in the Mini-buffer. The library remembers the last 60 commands executed. The following keys can be used to edit and recall commands when MINIBUF-RECALL has been loaded:</p>

<h3>up-arrow or esc-r</h3>

<p>Recalls the previous command in the command history.</p>

<h3>down-arrow or esc-v</h3>

<p>Recalls the next command in the command history.</p>

<h3>left-arrow</h3>

<p>Moves the cursor one character left in the Mini-buffer.</p>

<h3>right-arrow</h3>

<p>Moves the cursor one character right in the Mini-buffer.</p>

<h3>pgup and pgdn</h3>

<p>Pop up a buffer that allows you to select a line to recall from a list</p>

<h3>f1</h3>

<p>Pops up a Help window and lists the available options.</p>

<h3>f11</h3>

<p>Executes a command with completion.</p>

<h3>^g</h3>

<p>Aborts the Mini-buffer command.</p>


<h2><a name="mouse"></a>MOUSE, Mouse Support</h2>

<blockquote>
<p>The MOUSE library defines functions that support the use of a mouse with Barry's Emacs.</p>

<p>You can use the MOUSE library to:</p>

<p>&#183; Select windows</p>

<p>&#183; Position the cursor</p>

<p>&#183; Cut and paste regions of text</p>

<p>&#183; Change window sizes</p>

<p>&#183; Scroll a window up or down</p>

<p>&#183; Scroll a window left or right</p>

<p>&#183; Execute the keyboard macro at a specific position</p>

<p>In addition, you can customise the MOUSE library to perform specialised mouse actions for buffers, and you can build mouse support into your own MLisp code.</p>
</blockquote>


<h2><a name="usingthemouselibrary"></a>Using the MOUSE Library</h2>


<h2><a name="enablingmousesupport"></a>Enabling and Disabling Mouse Support</h2>

<p>To use the MOUSE library functions, add the following MLisp code to your EMACSINIT.ML:</p>

<p>(load "mouse")</p>

<p>(mouse-mode) mouse-on</p>

<p>With the MOUSE library loaded, you can turn on mouse support with the mouse-on function. mouse-on takes one argument which is a number describing the required mouse cursor. A value of 0 (the default) specifies the default mouse cursor. A value of 1 specifies a cross-hair cursor (the cross-hair cursor is supported only on VWS workstations).</p>

<p>When Emacs mouse handling is enabled, you do not have access to the workstation cut and paste features. To use workstation cut and paste with Emacs, you must disable Emacs mouse handling using the mouse-off function. When you want to use Emacs mouse handling again, re-execute the mouse-on function.</p>

<p>The easiest way to have mouse support enabled whenever you enter Emacs is to execute mouse-on from the enter-emacs-hook and return-to-emacs-hook functions. You should always disable Emacs mouse support when you leave Emacs and return to DCL. The easiest way to do this is to execute mouse-off from the leave-emacs-hook and exit-emacs-hook functions. <a href="#exampleenablingmouse">The example</a> shows how you can define the hook functions in your EMACSINIT.ML to enable and disable mouse support:</p>

<h3><a name="exampleenablingmouse"></a>Example: Enabling and Disabling Emacs Mouse Support</h3>

<pre>
;
; Set up Emacs hook functions to enable/disable
; mouse support.
;
(defun
    (my-return-to-emacs-actions
  (mouse-on 0) ; Turn on Emacs mouse support
  ;
  ; Other code to be executed on returning
  ; to Emacs
  ;
    )
)       ; defun - my-return-to-emacs-actions

(defun
    (my-leave-emacs-actions
  (mouse-off) ; Turn off Emacs mouse support
  ;
  ; Other code to be executed on leaving Emacs
  ;
    )
)       ; defun - my-leave-emacs-actions

(setq enter-emacs-hook "my-enter-emacs-actions")
(setq return-to-emacs-hook "my-enter-emacs-actions")
(setq exit-emacs-hook "my-leave-emacs-actions")
(setq leave-emacs-hook "my-leave-emacs-actions")
</pre>

<p>The MLisp code in <a href="#exampletogglemouse">the example</a> shows how to toggle the Emacs mouse on and off simply by pressing the F14 key. This provides easy access to the workstation cut and paste facilities from within Emacs.</p>

<h3><a name="exampletogglemouse"></a>Example: TOGGLEMOUSE --- Toggling the Emacs Mouse</h3>

<pre>
(declare-global ~togglemouse)
(setq ~togglemouse 0)
(defun
    (togglemouse
  (setq ~togglemouse
      (if ~togglemouse
    (progn
        ;
        ; Mouse was off, turn it on
        ;
        (mouse-on 0)
        (message "Emacs mouse enabled")
      (! ~togglemouse)
        )
        ; else
        (progn
      ;
      ; Mouse was on, turn it off
      ;
      (mouse-off)
      (message "Emacs mouse disabled")
          (! ~togglemouse)
      )
        )
    )
      )     ; if
  )
    )
)       ; defun - togglemouse
(bind-to-key "togglemouse" "f14)")
</pre>


<h2><a name="usingmousefeatures"></a>Using Mouse Features</h2>

<p>The following list describes how to use the various features provided by the Emacs mouse support. In the descriptions of each feature, MB1refers to mouse button 1, MB2 refers to mouse button 2, and MB3 refers to mouse button 3.</p>

<h3>position cursor</h3>

<p>Move the pointer to the position you wish to locate the cursor and click MB1. In overstrike mode, spaces (but not newlines) are inserted when needed to reach the selected position. In insert mode, no spaces are inserted, the cursor is placed at the end of the selected line.</p>

<h3>select window</h3>

<p>Move the pointer to the mode line of the window you wish to select, and click MB1.</p>

<h3>scroll window, vertical</h3>

<p>Grab part of the text by pointing to it with the pointer and pressing MB1. Move the mouse up or down to the position you would like the grabbed line to appear, then release MB1. The text is scrolled by a corresponding distance.</p>

<h3>scroll window, horizontal</h3>

<p>Grab part of the mode line with MB1 and move the mouse left or right. Release with the pointer still on the mode line. The window will be panned to the left or right a corresponding distance.</p>

<h3>change window size</h3>

<p>To make a window taller, shorter, narrower, or wider, grab the window's mode line, a vertical window border, or their intersection point, with MB1. Move the pointer to the new location of the mode line or border, and release MB1. Windows are deleted, if needed, to make room for the new window size.</p>

<h3>execute keyboard macro</h3>

<p>A double-click of MB1 positions the cursor at the selected location, and then executes the current keyboard macro at that location.</p>

<h3>copy region to kill buffer</h3>

<p>A click of MB2 copies the text from the current location of dot to the selected position into the Kill buffer. The cursor position remains as selected with the mouse. Moving the mouse between the press and release of MB2 will perform the same scroll/pan/resize functions as with MB1.</p>

<h3>kill region to kill buffer</h3>

<p>A double-click of MB2 kills the text from the current location of dot to the selected position into the Kill buffer.</p>

<h3>yank region from kill buffer</h3>

<p>A double-click of MB3 yanks the Kill buffer into the selected position. If you click on the mode line, the yank is performed at the current location of dot in the selected window. A single click of MB3 performs the same functions as MB1. Moving the mouse between the press and release of MB3 performs the same scroll/pan/resize functions as MB1.</p>


<p><b>NOTE: The following features work only with the VWS terminal emulator, not with the DECwindows DECterm emulator.</b></p>

<h3>copy region to local paste buffer</h3>

<blockquote>
<p>The keystroke <kbd>^X-c</kbd> copies the current select region into the terminal-wide cross-session paste buffer. The sequence <kbd>^X-MB2</kbd> copies the text from the current location of dot to the position selected into the cross-session paste buffer.</p>

<h3>yank from local paste buffer</h3>

<p>The keystroke <kbd>^X-^C</kbd> yanks the current contents of the terminal-wide cross-session paste buffer into the current buffer. The sequence <kbd>^X-MB3</kbd> pastes the paste buffer into the selected position.</p>
</blockquote>


<h2><a name="custommouselibrary"></a>Customising the MOUSE Library</h2>


<h3><a name="custommousecut"></a>Customising Mouse Cut and Paste</h3>

<p>By default, MOUSE uses the standard Kill buffer handling routines for performing cut and paste operations. If you are using a modified version of cut and paste, or some kind of kill ring library, you can communicate this to the mouse library by setting the favorite-... series of global variables defined by the MOUSE library. These are:</p>

<h3>favorite-set-mark</h3>

<p>A string variable containing the name of the function the MOUSE library should use to set the mark. This is set-mark by default.</p>

<h3>favorite-kill-region</h3>

<p>A string variable containing the name of the function the MOUSE library should use to kill the region to the Kill buffer. This is delete-to-killbuffer by default.</p>

<h3>favorite-copy-region</h3>

<p>A string variable containing the name of the function the MOUSE library should use to copy the region to the Kill buffer. This is copy-to-killbuffer by default (a function defined by the MOUSE library).</p>

<h3>favorite-yank</h3>

<p>A string variable containing the name of the function the MOUSE library should use to yank the contents of the Kill buffer into the current buffer. This is yank-from-killbuffer by default. KILLER, With the MOUSE library</p>

<p><a href="#examplekillermouse">The example</a> shows how to set these variables so that the KILLER cut and paste routines can be used with the MOUSE library. KILLER is described in <a href="#killer">KILLER, A Kill Ring System</a>.</p>

<h3><a name="examplekillermouse"></a>Example: Using KILLER with the MOUSE Package</h3>

<pre>
;
; Use the KILLER cut and paste functions
; with the MOUSE library.
;
(setq favorite-set-mark "kr-set-mark")
(setq favorite-copy-region "kr-copy-region")
(setq favorite-kill-region "kr-kill-region")
(setq favorite-yank "kr-yank")
</pre>

<p>When you use the mouse to scroll or pan windows, the default behaviour is for the scroll or pan to occur when the mouse button is released. If you set the variable mouse-continuous to 1, the scroll and pan functions will continuously update the display to reflect the position of the mouse pointer. Add the following MLisp line to your EMACSINIT.ML to use continuous scrolling:</p>

<pre>
(setq mouse-continuous 1)
</pre>

<p>Note that you need a fast communications line or a fast Xwindows environment to use continuous scrolling.</p>


<h2><a name="mlispprogrammingwithmouse"></a>Mlisp Programming with the Mouse</h2>

<p>To write MLisp code with a mouse interface, you must write a mouse action function in MLisp, then bind the function to a mouse button sequence. Pressing that mouse button sequence will then invoke the mouse action function.</p>

<p>The general scheme for a mouse action function is as follows:</p>

<ul>
<li>Declare local variables mousex, mousey, mouseevent and mouse-second-click. These are set by the mouse-parameters function to reflect the results of the most recent mouse click.</li>

<li>Execute the mouse-parameters function to set mousex to column, mousey to row, mouseevent to a code which indicates which button was used and whether it was pressed or released. mouse-second-click is a mouse-click counter, and is set to 1 on the second click if you double-click a mouse button.</li>

<li>Execute the MLisp line (mouse-reposition mousex mousey mouseevent)to position the cursor. mouse-reposition also performs parts of the mode-line and scrolling operations when necessary.</li>
</ul>

<p>See the <a name="templatemouseaction">template mouse action function</a> that illustrates how to program both for single and double mouse clicks. When written in this way, your local mouse action functions retain the pan and scroll features of the default mouse actions.</p>

<h3><a href="#templatemouseaction"></a>Example: Template Mouse Action Function</h3>

<pre>
(defun
    (my-local-mouse-action
  mousex
  mousey
  mouseevent
  mouse-second-click
  ;
  ; Fetch the mouse parameters and position the cursor.
  ;
  (mouse-parameters)
  (mouse-reposition mousex mousey mouseevent)
  ;
  ; At this point, the cursor has been positioned at a
  ; location specified by the mouse cursor.
  ;
  (if mouse-second-click _ ; Check for double-click
      (progn
    ;
    ; If action is desired only on the second click,
    ; place it here.
    ; Note that the action of the double click must be a
    ; logical superset of the action of the single click
    ; (the single click code is always executed if it
    ; exists).
    ;
      )
      (progn ; else
    ;
    ; If action is desired on the first click, place it
    ; here, otherwise leave out the else clause.
    ;
      )
  )     ; if
    )
)       ; defun - my-local-mouse-action

(local-bind-to-key "my-local-mouse-action" "mouse-1-down)")
</pre>

<p><a name="mousebuttonescapes"></a>You can bind your own local mouse action functions to any of the <a href="#mousebuttonescapes">mouse button escapes</a> listed in the table.</p>

<table>
<tr>
<td align="Left" valign="Top">mouse-1-down</td>
<td align="Left" valign="Top">mouse-1-up</td>
</tr>

<tr>
<td align="Left" valign="Top">mouse-2-down</td>
<td align="Left" valign="Top">mouse-2-up</td>
</tr>

<tr>
<td align="Left" valign="Top">mouse-3-down</td>
<td align="Left" valign="Top">mouse-3-up</td>
</tr>
</table>

<p>Note that it is possible to include Escape or function key prefixes in mouse button bindings.
For example, the following bindings are all legal:</p>

<pre>
(local-bind-to-key "my-local-mouse-action" "\[mouse-1-down])")
(local-bind-to-key "my-local-mouse-action" "\^c\[mouse-1-down])")
</pre>
<p><a href="#examplemousebindings">The example</a> contains a complete mouse programming example. The example is intended for use with the Emacs Notes package, and binds several useful actions to MB3. For example, clicking MB3 on a conference name in a conference directory will open the conference, and clicking MB3 on a note in a note directory will read the selected note.</p>

<h3><a name="examplemousebindings"></a>Example: Example Mouse Bindings for the Notes Package</h3>

<pre>
;
; Mouse bindings for the Notes package.
;
; When pressing MB3, do the most appropriate thing
; depending on which buffer is selected.
;
(defun
    (my-notes-action
        mousex
        mousey
        mouseevent
        mouse-second-click
        ;
        ; Get the mouse parameters and position the cursor at the
        ; selected position.
        ;
        (mouse-parameters)
        (mouse-reposition mousex mousey mouseevent)
        ;
        ; Depending on which buffer was selected with the mouse,
        ; perform the most appropriate action.
        ;
        (if
            (= current-buffer-name notes-notebook-entry-directory)
            (notes-c-open)
            (= current-buffer-name notes-notebook-class-directory)
            (notes-c-set-class)
            (= current-buffer-name notes-notefile-directory)
            (notes-c-read-note)
            (= current-buffer-name notes-notefile-header)
            (notes-c-close)
            (= current-buffer-name notes-notebook-header)
            (notes-c-exit)
            (notes-c-enter-key)
        )
    )
)

(local-bind-to-key "my-notes-action" "mouse-3-up)")
(local-bind-to-key "novalue" "mouse-3-down)")
</pre>


<h2><a name="mouserectangular"></a>MOUSE-RECTANGULAR, Mouse Interface to the RECTANGULAR Library</h2>

<p>The MOUSE-RECTANGULAR library provides a workstation mouse interface to the rectangular cut and paste routines defined in the RECTANGULAR library. You must load the RECTANGULAR library before loading the MOUSE-RECTANGULAR library. The RECTANGULAR library is described in <a href="#rectangular">RECTANGULAR, Rectangular Cut and Paste</a>.</p>

<p>The MOUSE-RECTANGULAR mouse button bindings are:</p>

<h3>esc-mouse button 1</h3>

<p>Rectangular copy between text cursor and mouse pointer position.</p>

<h3>esc-mouse button 2</h3>

<p>Rectangular cut between text cursor and mouse pointer position.</p>

<h3>esc-mouse button 3</h3>

<p>Rectangular paste at mouse pointer location.</p>

<p>If Replace Mode is active, the Replace Mode versions of the rectangular cut and paste routines are used.</p>


<h2><a name="newcompil"></a>NEWCOMPIL, Compiling Programs</h2>

<p>The NEWCOMPIL library provides a more convenient program compilation interface than the compile-it and next-errorfunctions built in to Emacs. After loading the NEWCOMPIL library, compile-it and next-error are modified so that while compilation is in progress, other work in Emacs can continue. The standard functions do not provide this capability. kill-compilation</p>

<p>An extra command is provided to cater for this extra flexibility: <kbd>^X-^K</kbd> (kill-compilation), which aborts the currently active compilation.</p>


<h2><a name="number"></a>NUMBER, Number Base Conversion</h2>

<p>The NUMBER library defines functions to convert a number into hexadecimal, octal and decimal notation and display the result in the Mini-buffer.</p>

<p>The interface to the base conversion functions is the numberfunction. When executed, number prompts for a number to convert. The number can be one of the following forms:</p>

<table>
<tr>
<td align="Left" valign="Top">dddddd</td>
<td align="Left" valign="Top">Decimal</td>
</tr>

<tr>
<td align="Left" valign="Top">0ooooooo</td>
<td align="Left" valign="Top">Octal</td>
</tr>

<tr>
<td align="Left" valign="Top">0xhhhhh</td>
<td align="Left" valign="Top">Hexadecimal</td>
</tr>
</table>

<p>The number function then returns the specified value in hexadecimal, octal and decimal formats in the Mini-buffer. For example, if the value 55 is entered, number returns:</p>

<p>Converted 55 to: 0x37 067 55</p>

<h2><a name="python"></a>PYTHONMODE, Python mode</h2>

<p>An editing mode for Python code. Python mode provide syntax colouring for Python code.</p>

<p>Python is a well designed, object oriented, simple to learn, scripting language. Python is available for Windows, Unix and Mac systems. The home of Python is <a href="http://www.python.org">www.python.org</a></p>


<p><b>(Python-mode)</b></p>

<blockquote>
<p>Start Python mode on the current buffer</p>
</blockquote>


<h2><a name="rectangular"></a>RECTANGULAR, Rectangular Cut and Paste</h2>

<p>The RECTANGULAR library provides the ability to cut and paste rectangular areas of text bounded by any two opposite corners. The corners can be in the same row or column. RECTANGULAR handles Tab characters correctly and fixes problems in the AREA package. RECTANGULAR functions correctly in insert or replace mode.</p>

<p>To handle all possible options, there are two modes for cut and two modes for paste which are controlled by the following variables:</p>


<p><b>replace-with-white-space</b></p>

<blockquote>
<p>Controls the action of the rectangular cut function. When this variable is set to 1, deleted text is replaced with white-space. When the variable is set to 0, text is deleted and is not replaced with white-space.</p>
</blockquote>


<p><b>overstrike-mode</b></p>

<blockquote>
<p>Controls the action of the rectangular paste function. When this variable is set to 1, text is pasted in overstrike (replace) mode. When the variable is set to 0, text is pasted in insert mode.</p>

<p>The rectangular cut and paste key bindings and commands are:</p>
</blockquote>


<p><b>GOLD-Select (rectangular-select)</b></p>

<blockquote>
<p>Selects one corner of the area to be cut.</p>
</blockquote>


<p><b>Remove (rectangular-cut)</b></p>

<blockquote>
<p>Cuts the selected area from the buffer with replace-with-white-space set to 0.</p>
</blockquote>


<p><b>GOLD-Remove (rectangular-cut)</b></p>

<blockquote>
<p>Cuts the selected area from the buffer with replace-with-white-space set to 1.</p>
</blockquote>


<p><b>Insert Here (rectangular-paste)</b></p>

<blockquote>
<p>Pastes the previously-cut text into the buffer at dot in insert mode (overstrike-mode set to 0).</p>
</blockquote>


<p><b>GOLD-Insert Here (rectangular-paste)</b></p>

<blockquote>
<p>Pastes the previously-cut text into the buffer at dot in replace mode (overstrike-mode set to 1).</p>

<p>The following convenience functions are also defined:</p>

<h3>rect-cut-space</h3>

<p>Performs a rectangular cut with replace-with-white-space set to 1.</p>

<h3>rect-cut</h3>

<p>Performs a rectangular cut with replace-with-white-space set to 0.</p>

<h3>rect-paste</h3>

<p>Performs a rectangular paste with overstrike-mode set to 0.</p>

<h3>rect-paste-overstrike</h3>

<p>Performs a rectangular paste with overstrike-mode set to 1.</p>

<p>To cut a rectangular area from the buffer, move the cursor to one corner of the area to be cut and press GOLD-Select. Then move to the opposite corner and press either Remove or GOLD-Remove. Tabs replaced by spaces in the cut area.</p>

<p>When you cut a rectangular area where one of the corners is a space character, the highlighted space may remain highlighted after the cut operation is completed. To remove the highlighting, type ^L(redraw-display) and Emacs will redraw the display with the highlighting removed.</p>

<p>To paste a previously cut area back into the buffer, move the cursor to the desired location and type either Insert Here or GOLD-Insert Here. White-space at the ends of lines affected by the rectangular paste will first be removed.</p>

<p>Here are some examples:</p>

<p>Remove --- removes the area and the text moves to to fill the hole:</p>

<p>aaaaaaaaabb aaaaaaaaabb</p>

<p>aaaaaaaaabb -------&gt; aabb</p>

<p>aaaaaaaaabb aabb</p>

<p>aaaaaaaaabb aaaaaaaaabb</p>

<p>GOLD-Remove --- removes the area and leaves a hole:</p>

<p>aaaaaaaaabb aaaaaaaaabb</p>

<p>aaaaaaaaabb ------&gt; aa bb</p>

<p>aaaaaaaaabb aa bb</p>

<p>aaaaaaaaabb aaaaaaaaabb</p>

<p>Insert Here --- inserts the area into the text in insert mode:</p>

<p>oooo aa$$$*** aaoooo$$$***</p>

<p>oooo aa$$$*** aaoooo$$$***</p>

<p>oooo + aa$$$*** -------&gt; aaoooo$$$***</p>

<p>oooo oooo</p>

<p>oooo oooo</p>

<p>Text to Original</p>

<p>be inserted text</p>

<p>GOLD-Insert --- inserts the area in the text in replace mode:</p>

<p>oooo aa$$$*** aaoooo**</p>

<p>oooo aa$$$*** aaoooo**</p>

<p>oooo + aa$$$*** -------&gt; aaoooo**</p>

<p>oooo oooo</p>

<p>oooo oooo</p>

<p>Text to Original</p>

<p>be inserted text</p>
</blockquote>


<h2><a name="tags"></a>TAGS, An Indexing System</h2>

<blockquote>
<p>The TAGS library defines functions which remember the locations of function definitions in a file, and enable you to go directly to the definition of any function without having to search the whole file.</p>

<p>The TAGS package can be used to tag a set of files used to build a program as well as an individual file.</p>

<p>Any text file or set of files may be tagged, not just computer programs. All that is required is that some entity be used to initially create the tags.</p>

<p>The functions provided by the TAGS library are summarised here and are described in detail in the following sections.</p>
</blockquote>


<p><b>(make-tag-table)</b></p>

<blockquote>
<p>Makes a tag table for a specified set of files.</p>
</blockquote>


<p><b>(set-tag-language)</b></p>

<blockquote>
<p>Sets the tag language to a user-specified language. This is used when files being tagged are not known to the TAGS library.</p>
</blockquote>


<p><b>(recompute-all-tags)</b></p>

<blockquote>
<p>Updates all the tags in the tag table.</p>
</blockquote>


<p><b>(visit-tag-table)</b></p>

<blockquote>
<p>Tells Emacs which tag table file to use.</p>
</blockquote>


<p><b>^X-^L (goto-tag)</b></p>

<blockquote>
<p>Moves dot to the specified tag, visiting the appropriate file if necessary.</p>
</blockquote>


<p><b>^X-^A (add-tag)</b></p>

<blockquote>
<p>Adds a new tag to the current tag table.</p>
</blockquote>


<p><b>(list-tags)</b></p>

<blockquote>
<p>Lists all tags in the current tag table.</p>
</blockquote>


<p><b>(tag-replace-string)</b></p>

<blockquote>
<p>Replace a string in all files in the current tag table.</p>
</blockquote>


<p><b>(tag-query-replace-string)</b></p>

<blockquote>
<p>Perform a query-replace operation on all files in the tag table.</p>
</blockquote>


<p><b>(tag-execute-mlisp)</b></p>

<blockquote>
<p>Execute an MLisp expression over all files in the tag table.</p>
</blockquote>


<p><b>How to Make a Tag Table for a Program</b></p>

<blockquote>
<p>To use the TAGS package, you must create a tag table from the source file or files in your program. Normally, the tag table does not reside in any of these files, but in a separate tag table file which contains the names of the text files which it describes. Tag table files are generated using the <kbd>ESC-x make-tag-table command</kbd>. make-tag-table asks you to specify the names of the files you wish to tag (which may contain wildcards), then proceeds to read all the files matching that file specification into Emacs. It then uses a set of built-in rules to tag the lines according to the source language. TAGS selects the language based on the file's extension. TAGS has built-in rules for building tag tables for the following languages:</p>

<p>&#183; MLisp</p>

<p>&#183; C, C++</p>

<p>&#183; Python</p>

<p>&#183; BLISS, BLISS-16, BLISS-32</p>

<p>&#183; RUNOFF</p>

<p>&#183; MACRO-32</p>

<p>&#183; FORTRAN. set-tag-language</p>

<p>If the language you wish to tag does not have built-in rules, you will have to teach TAGS how to recognise the lines to be tagged by using the <kbd>ESC-x set-tag-language</kbd> command. This command asks for a file type for the language and a regular expression search string to use to select lines to be tagged. Only one extra language can be specified; multiple calls of set-tag-language overwrite previous language specifications. recompute-all-tags</p>

<p>Once a tag table file exists, you must update it if you add new tags to the source files, or change the files extensively. You can do this by using the command <kbd>ESC-x recompute-all-tags</kbd>. TAGS finds the names and languages of the source files by reading the old tag table.</p>
</blockquote>


<h2><a name="howusetags"></a>How to Tell Emacs You Want to Use TAGS</h2>

<p>Before you can use the TAGS package, you have to load the library using the <kbd>ESC-x execute-mlisp-file</kbd> command. visit-tag-table</p>

<p>Before you can access a particular tag, you have to tell TAGS the name of the tag table file you want to use. This is done with the command <kbd>ESC-x visit-tag-table</kbd>. TAGS can only know about one tag table file at a time; executing a second <kbd>ESC-x visit-tag-table</kbd> command will overwrite any existing tag table (including any changes you may have made to it).</p>

<p>If no tag table has been specified and you attempt to find a tag, Emacs will read in the default tag table called SYS$DISK:[]TAGS.TAG.</p>

<p>visit-tag-table is essentially equivalent to selecting the buffer *TAGS* (which is where the tags live) and visiting the tag table file in that buffer, then returning to the previously selected buffer. After execution of visit-tag-table, <kbd>ESC-x list-buffers</kbd> will show the buffer *TAGS* visiting the tag table file.</p>


<p><b>Jumping to a Tag</b></p>

<blockquote>
<p>To jump to the definition of a tagged item, use the command <kbd>^X-^L</kbd> (goto-tag). You will go straight to the definition of the tag you want. If the definition is in a different file, TAGS will visit that file and locate the tag. If it is in the same file, TAGS moves dot to the appropriate place.</p>

<p>You do not need to type the complete name of the tag to be found; any substring will do. If you use this feature, you may not always find the tag you expected; when this happens, <kbd>^U-^X-^L</kbd> will find the next definition matching the tag substring. For example, if you want to find the definition of X-SET-TYPE-1 and you specify just TYPE-1, you might find X-READ-TYPE-1 instead. You could then type <kbd>^U-^X-^L</kbd> until you reach X-SET-TYPE-1.</p>
</blockquote>


<h3><a name="otheroperationsontags"></a>Other Operations on Tag Tables</h3>

<blockquote>
<p>When you define a new function, its location does not go in the tag table automatically. This is because Emacs cannot tell that you have defined a function unless you tell it by invoking the command <kbd>^X-^A</kbd> (add-tag).</p>

<p>When you type the command <kbd>^X-^A</kbd>, dot should be on the line that introduces the function definition. Thus, in a Lisp program, you might type (defun (foo) and then type <kbd>^X-^A</kbd> to define a tag for the foo function.</p>

<p>add-tag modifies only the copy of the tag table loaded into Emacs. To modify the tag table file itself, you must save the tag table to disk. <kbd>^X-^M</kbd> (write-modified-files) is the easiest way to do this.</p>

<p>Although local modifications to a file do not degrade the efficiency of the TAGS package or require that the tag table be rebuilt, moving a function a great distance makes finding that function much slower. In this case, you can add the function to the tag table with <kbd>^X-^A</kbd> to give the table its new location. Alternatively, you can run recompute-all-tags to update everything, as is usually done.</p>
</blockquote>


<h2><a name="vistingafunction"></a>Visiting a Function</h2>

<p>The command <kbd>ESC-x visit-function</kbd> can be used to temporarily view a function in another window. Type the function's name in the buffer, then execute visit-function. The function's name is extracted from the buffer and used as a tag to find. Before the tag is located, TAGS enters a recursive edit, so that when you have finished viewing the function, your original windows and buffers are re-displayed.</p>

<h3>finding out what has been tagged</h3>

<p>The function list-tags can be used to list the files and functions that have been tagged for any tag table. Just load the tag table and call the function. When you use make-tag-table, the list-tags function is automatically called so that you can see exactly what TAGS has tagged.</p>

<h3>replacing strings in a tagged program</h3>

<p>Two functions can be used to change all occurrences of a string in a set of files that have been tagged: tag-replace-string and tag-query-replace-string. Both of these functions require a regular expression search string and a replacement string as arguments, and apply the appropriate replace commands to all of the files tagged in the tag table.</p>

<h3>applying mlisp to lines in a tagged program</h3>

<p>A more flexible approach to multiple file editing is provided by the function tag-execute-mlisp. This function requires a regular expression search string which is used to find lines in all the files specified in the tag table. For all of the lines that match the pattern, the function sets dot to the found line, and executes a specified MLisp expression at that location.</p>


<h2><a name="whatconstitutesatag"></a>What Constitutes a Tag?</h2>

<p>The following list describes what defines an item to be tagged using the built-in tagging rules for the supported languages. Any of these definitions may be overriden using the set-tag-language command.</p>

<table>
<tr>
<td><strong>C</strong></td>
<td>matches file type .c, .cpp and .cxx and tags lines that start a C or C++ routine or #define symbol. C++, ANSI C and K&amp;R C are correctly tagged.</td>
</tr>

<tr>
<td><strong>MLisp</strong></td>
<td>matches file type .ml and tags lines that start with (defun where all white space is optional.</td>
</tr>

<tr>
<td><strong>Python</strong></td>
<td>matches file type .py and .pyw and tags lines that start with def or class.</td>
</tr>

<tr>
<td><strong>BLISS</strong></td>
<td>matches file type .BLI and tags all lines that start with optional white space and contain either ROUTINE or GLOBAL ROUTINE.</td>
</tr>

<tr>
<td><strong>BLISS-16</strong></td>
<td>matches file type .B16 and tags lines as BLISS does.</td>
</tr>

<tr>
<td><strong>BLISS-32</strong></td>
<td>matches file type .B32 and tags lines as BLISS does.</td>
</tr>

<tr>
<td><strong>RUNOFF</strong></td>
<td>matches file type .RNO and tags lines that start with .CH, .HL or .AX.</td>
</tr>

<tr>
<td><strong>FORTRAN</strong></td>
<td>matches file type .FOR and tags lines containing SUBROUTINE or FUNCTION.</td>
</tr>
</table>


<h2><a name="addingorremovingsource"></a>Adding or Removing Source Files</h2>

<p>A tag table file is a sequence of entries, one per file. Each entry looks like:</p>

<pre>
^-filename
^Adata line^Bchar pos
</pre>

<p>where:
<br />
<span class="cmd">filename</span> is the file name and file type of the file for which the following lines are tag information.
<br />
<span class="cmd">data line</span> contains the tag's line
<br />
<span class="cmd">char pos</span> is the position of the start of the tagged line.</p>

<p>If you are changing a source file's name, you should simply change the name where it is presently described in the tag table.</p>

<p>To add a new source file, simply insert a dummy entry containing the filename and update the tag table. The dummy will then be turned into a real entry.</p>

<p>You can delete a source file from a tag table by deleting its entire entry. Since the counts of the remaining entries are still valid, you need not run recompute-all-tags over the file again. You can also change the order of the entries without doing any harm. The order of the entries matters if there are tags which appear in more than one source file.</p>


<h2><a name="tabs"></a>TABS, Intelligent Tab Handling</h2>

<p>The TABS library defines functions that insert and delete Tab characters in an intelligent way. The functions use the buffer-specific variable logical-tab-size to compute how much whitespace to insert or delete. The two functions defined are:</p>

<p><b>(tab-key)</b></p>

<blockquote>
<p>Inserts enough tabs and spaces to move to the next tab stop as indicated by logical-tab-size.</p>
</blockquote>

<p><b>(tab-delete)</b></p>

<blockquote>
<p>Deletes enough tabs and spaces to move back to the previous tab stop as indicated by logical-tab-size.</p>
</blockquote>


<h2><a name="time"></a>TIME, A Running Time Display</h2>

<p>The TIME library defines the time function. When executed, the time function puts a running digital time display of the form HH:MM:SS in the mode line of the current window.</p>

<p>When you move the cursor to a new window or visit a new file, the time display is added to the new mode line and is made active.</p>

<p>The time display is only active in the current window's mode line. If the time display is enabled in any other window, the time shown is the time that the cursor was moved out of that window.</p>


<h2><a name="whereis"></a>WHEREIS, Where Is That Command?</h2>

<p>The WHEREIS library defines the where-is function, which prompts for a function name and displays in the Mini-buffer the key binding (if any) to which the function is bound.</p>

<p>where-is cannot be called from an MLisp program.</p>


<h2><a name="white-space-mini-mode"></a>WHITE-SPACE-MINI-MODE, check for white space problems</h2>

<p>The WHITE-SPACE-MINI-MODE library adds the ability to highlight white spaces problems.</p>
<p>This library should be loaded before other language modes.</p>

<p>Which problems are checked for is controlled by the following variables:</p>

<ul>
<li>check-for-white-space-problems
    <ul>
    <li>highlight white space at the end of lines</li>
    <li>highlight space before tab</li>
    </ul>
    </li>
<li>check-for-use-of-tabs-problems
    <ul>
    <li>highlight use of any tabs</li>
    </ul>
    </li>
</ul>

<p>Typically add the following to emacsinit.ml:</p>

<pre>
(load "white-space-mini-mode")
(setq check-for-white-space-problems 1)
(setq check-for-use-of-tabs-problems 1)
</pre>


<h2><a name="writereg"></a>WRITEREG, Write Region to File</h2>

<p>The WRITEREG library defines the single function write-region-to-file which prompts for a file name and writes the region to the specified file.</p>
</div>
</body>
</html>

