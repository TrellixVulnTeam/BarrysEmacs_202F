<chapter>(Advanced Editing Facilities\advedit_chap)

<p>
This chapter describes EMACS' advanced editing facilities.  The following
features are covered:

<list>(unnumbered)

<le>
<reference>(escx_sec) describes how EMACS extended commands work.

<le>
<reference>(levels_sec) describes how to move up and down recursive
editing levels.

<le>
<reference>(markregion_sec) describes the EMACS <newterm>(mark) and
<newterm>(region).

<le>
<reference>(delmovtxt_sec) shows how to move regions of text
around.

<le>
<reference>(typos_sec) shows how to correct typographical errors
in text.

<le>
<reference>(advfile_sec) describes advanced file-handling features.

<le>
<reference>(controldisp_sec) describes how to control the EMACS display.

<le>
<reference>(multibuf_sec) describes how to control multiple
buffers inside the same EMACS.

<le>
<reference>(multiwin_sec) describes how to handle multiple windows.

<le>
<reference>(narrowing_sec) describes the <newterm>(narrowing) feature.

<le>
<reference>(searching_sec) describes EMACS' normal and regular expression
searching facilities.

<le>
<reference>(replace_sec) describes EMACS text replacement commands.

<le>
<reference>(abbrevinput_sec) describes how to use <newterm>(Abbreviation Mode)
to handle abbreviated input.

<le>
<reference>(kbmacro_sec) describes how to create and execute keyboard
macros.

<endlist>


<head1>(Extended <oparen>ESC-x<cparen> Commands and Functions\escx_sec)

<x>(Extended commands)
<x>(ESC-x commands)

<p>
Not all EMACS commands are of the one- or two-character variety. All commands
have long names composed of English words separated with dashes. This is
because the long names are easier to remember and are more suggestive of
the command actions than the one- or two-character short forms.

<p>
The commands with long names are known as <newterm>(extended commands) or
<newterm>(functions) because they extend the set of one- and two-character
commands.

<head2>(Issuing Extended Commands\issextcmd_sec)

<definition_list>
<deflist_item>(ESC-x or GOLD-KP7 (execute-extended-command))
<x>(ESC-x)
<deflist_def>
Begins an extended command.

<enddefinition_list>

<p>
Extended commands are also called <newterm>(ESC-x) commands, because they all
start with the characters <key_name>(ESC-x). <key_name>(ESC-x) is followed
by the command's long, suggestive name (this is actually the name of the
function to be called). Terminate the name of the function with a
<key_name>(Return).  For example,
<quote>(<cx>(ESC-x delete-white-space<key>(Return)))
invokes the function <key_name>(delete-white-space).

<p>
We say that <quote>(<cx>(ESC-x FOO)) calls the function
<quote>(<key_name>(FOO)). When documenting the individual extended
commands, we will call them functions to avoid confusion between them and
the one- or two-character commands. We also use <key_name>(ESC-x) as a
title for functions. The extended command is what you type, starting with
<key_name>(ESC-x), and what the command does is call a function.

<p>
There are a great many functions in EMACS for you to call. They are
described throughout this manual, according to what they do. Here, we are
concerned only with extended commands in general.

<head2>(Typing the Command Name\typecmd_sec)

<x>(Mini-buffer ^G)
<x>(Mini-buffer ^<literal>(\))
<p>
When you type <key_name>(ESC-x), the cursor moves down to the Mini-buffer at
the bottom of the screen.  A colon is printed there, and when you type the
command name it is echoed. You can use all the usual editing commands
while in the Mini-buffer, except that all the commands which are usually
bound to <key_name>(Escape) are now bound to <key_name>(^<literal>(\)). A
<key_name>(^G) cancels the whole <key_name>(ESC-x) command. These editing
characters apply any time EMACS reads a line in the Mini-buffer, not just
within <key_name>(ESC-x).

<p>
The colon which appears in the Mini-buffer is called a <newterm>(prompt).
The prompt always tells you what sort of argument is required and what it
is going to be used for; a colon means that you are using the command
<key_name>(ESC-x), and that you should type the name of a function to be
called.

<head2>(Command Completion\completion_sec)

<p>
You can abbreviate the name of the command, typing only as much as is
needed to identify the command unambiguously.  This is knows as
<newterm>(command completion).

<p>
Using completion, you need type
only part of the command name, and EMACS can then visibly fill in the
rest, or as much as can be determined from the part you have typed.

<x>(Escape)
<x>(Do)
<p>
You request completion by typing an <key_name>(Escape) (or <key_name>(Do)
on LK201 keyboards). For example, if you type
<keep>(<quote>(<cx>(ESC-x del<key>( Do )))), the <quote>(<cx>(del)) expands to
<quote>(<cx>(delete-)) because all command names which start with
<quote>(<cx>(del))
continue with <quote>(<cx>(ete-)). If you ask for completion when there
are several alternatives for the next character, a help window is
displayed to show you the alternatives you can select.  This window
automatically disappears when the information is no longer relevant.

<p>
The <key_name>(Escape) or <key_name>(Do) keys are also used to terminate
the command name and begin the arguments, but this only happens if the
command name completes in full. In practice, the two meanings of
<key_name>(Escape) and <key_name>(Do) do not conflict, because if the
command name is not complete, it is ambiguous and will not be accepted.

<x>(Help)
<p>
Typing the <key_name>(Help) key in the middle of the command name prints a
list of all the command names which begin with the text you have typed so far.
You can then go on typing the name. If you type <key_name>(Help) before
typing any other commands, EMACS fills the help window with the names of
all the available functions.  The help window will be removed
from the screen when the command name has been completely entered.

<p>
Note that if the EDTSIM or the LK201 packages have not been loaded, the
default completion character is <key_name>(Escape) and the default help
character is <key_name>(?).

<head2>(Numeric and String Arguments\numstrarg_sec)

<p>
Some functions can use numeric prefix arguments. Simply give the
<key_name>(ESC-x) command an argument and <key_name>(ESC-x) will pass it
along to the function which it calls.

<p>
Some functions require string arguments (sometimes called
<newterm>(suffix arguments)). When a function's name has been completely
filled in, the function will prompt for arguments. If information is to be
selected from a list of alternatives, then completion will be enabled for
those functions.  Arguments should be separated with a <key_name>(Return)
when complete.

<p>
For example, the function <key_name>(describe-command) prints the full
documentation of a function whose name must be given as a string argument.
Using completion to enter the command, you might type:

<online_popup>(example)
<code_example>
ESC-x desc<key>(Escape)com<key>(Escape)print-d<key>(Escape)
<endcode_example>
<endonline_popup>

<cp>
to display information about the <key_name>(print-default) function.


<head1>(Moving Up and Down Levels\levels_sec)

<p>
<newterm>(Subsystems) and <newterm>(recursive editing levels) are two
states in which you are temporarily doing something other than editing the
visited files as usual. For example, you might be editing a word's
definition for the <key_name>(ESC-x describe-word-in-buffer) command, or
looking at a documentation file with INFO. Running another subprocess
under EMACS can also be thought of as a sublevel.

<head2>(Subsystems\subsys_sec)

<p>
A <newterm>(subsystem) is an EMACS function which is an interactive program in
its own right: it reads commands in a language of its own, and displays the
results. You enter a subsystem by typing an EMACS command which invokes it,
or by invoking it directly from DCL. Once entered, the subsystem runs
until a specific command to exit the subsystem is typed. An example of an
EMACS subsystem is INFO, the documentation reading program.

<p>
The commands understood by a subsystem are not like normal EMACS
commands, because their purpose is something other than editing text. For
example, INFO commands are designed for moving around in a tree-structured
documentation file. In EMACS, most commands are control or escape
sequences because printing characters insert themselves. In most
subsystems, there is no insertion of text, so non-control characters can
act as commands.

<p>
While you are inside a subsystem, the mode line usually gives the name of
the subsystem, as well as other information optionally supplied by the
subsystem.  For example, INFO displays the current file name and node name.

<p>
Since each subsystem implements its own commands, we cannot guarantee
anything about these commands. However, there are conventions as to the
action of certain commands:

<definition_list>
<deflist_item>(Backspace)
<deflist_def>
Scrolls backward, like <key_name>(ESC-v) in EMACS.

<deflist_item>(Space)
<deflist_def>
Scrolls forward, like <key_name>(^V) in EMACS.

<deflist_item>(q)
<deflist_def>
Exits the subsystem.

<deflist_item>(x)
<deflist_def>
Begins  an  extended command, like <key_name>(ESC-x) in EMACS.

<deflist_item>(?)
<deflist_def>
Displays help on  the  subsystem's commands.

<enddefinition_list>

<p>
Note that not all of these commands necessarily exist in every subsystem.
Try the <key_name>(?) key to see which commands a subsystem does define.

<head2>(Recursive Editing Levels\recursedit_sec)

<p>
A <newterm>(recursive editing level) is a state in which part of the
execution of one command involves doing some editing. You may be editing
the file you are working on, or you may be editing something totally
different from what you were working on at top level. Recursive editing
levels are indicated in the mode line by square brackets.

<p>
For example, the command <key_name>(^U-^X-^D) calls the function
<key_name>(describe-word-in-buffer) and lets you edit an existing word's
description. During the execution of this command, you enter a recursive
editing level in which you alter or create the new definition. While this
is going on, the mode line contains
<quote>(<cx>([Edit description word: word xxx])) to inform you that you
are in a recursive editing level. When you exit the recursive
editing level, the <key_name>(describe-word-in-buffer) command continues
its work by inserting the entry into the <key_name>(subr-names) database. Only
then is the original <key_name>(ESC-x describe-word-in-buffer) command
finished.

<p>
Alternatively, you can abort the recursive editing level, which gets you out
of the <key_name>(ESC-x describe-word-in-buffer) command and back to top level,
without allowing the command to finish.

<p>
A recursive editing level differs from a subsystem in that the commands are
ordinary EMACS commands (although a few may be slightly
modified), whereas a subsystem defines its own commands. The text
you edit inside a recursive editing level depends on the command which
invoked the recursive editing level.

<head2>(Exiting Levels and EMACS\exiting_sec)

<definition_list>
<deflist_item>(^C (exit-emacs))
<x>(^C)
<x>(exit-emacs)
<deflist_def>
Exits from EMACS or from a  recursive  editing level.

<deflist_item>(ESC-x top-level)
<x>(top-level)
<deflist_def>
Returns to the top level, aborting all recursive edits, packages and
subsystems.

<deflist_item>(ESC-x pause-emacs)
<x>(pause-emacs)
<deflist_def>
Temporarily returns to DCL.   The paused EMACS may be re-started at a later
time.

<enddefinition_list>

<p>
The general EMACS exit command is <key_name>(^C). This command is used
to exit from a recursive editing level back to the top level of EMACS, and
to exit from EMACS at top level back to DCL.

<p>
We cannot say in general how to exit a subsystem, since each subsystem
defines its own command language. The convention is to use the
<key_name>(Q) key.

<x>(pause-emacs)
<p>
You can exit from EMACS back to the parent process at any time (even
from within a recursive editing level) using the <key_name>(ESC-x
pause-emacs) command. If you use this command while inside a
recursive editing level, when EMACS is re-entered you will still be
inside the recursive editing level.

<x>(^X-^M)
<p>
Exiting EMACS does not normally save visited files, because it is not
always true that you exit EMACS only when you have finished editing. If
you want files saved, you must use <key_name>(^X-^M) before exiting.
However, if modified buffers exist when you exit, EMACS will ask you to
confirm that you wish to discard the edits you have made.

<p>
Several variables are provided that allow you to modify the
default action when you enter and exit EMACS.  These are:

<definition_list>
<deflist_item>(enter-emacs-hook)
<x>(enter-emacs-hook)
<deflist_def>
Can be set to a function to be executed when EMACS is initially entered.

<deflist_item>(exit-emacs-hook)
<x>(exit-emacs-hook)
<deflist_def>
Can be set to a function to be executed when EMACS finally exits.

<deflist_item>(return-to-emacs-hook)
<x>(return-to-emacs-hook)
<deflist_def>
Can be set to a function to be executed when EMACS re-starts after an
<key_name>(ESC-x pause-emacs) command.

<deflist_item>(leave-emacs-hook)
<x>(leave-emacs-hook)
<deflist_def>
Can be set to a function to be executed when <key_name>(ESC-x pause-emacs) is
executed.

<enddefinition_list>

<head2>(Interactive DCL Subprocesses\dclsubproc_sec)
<x>(return-to-monitor)

<p>
An alternative to exiting EMACS or using <key_name>(ESC-x pause-emacs) is to
create another subprocess under EMACS. You can probably do in a subprocess
whatever you would have done after exiting EMACS, and the subprocess will not
interfere with EMACS' operation. Use the <key_name>(ESC-x
return-to-monitor) command to start a subprocess, then use the DCL LOGOUT
command to return to EMACS.

<p>
All symbols and un-confined process logical names are propagated to the
subprocess.


<head1>(The Mark and the Region\markregion_sec)

<p>
In general, a command which processes an arbitrary part of the buffer must
know where to start and where to stop. In EMACS, such commands usually
operate on the text between dot and <newterm>(mark)---this range of text
is called the <newterm>(region). To specify a region, you position dot at
one end of the region, and set mark at the other end. It does not matter
which end is positioned first, or which end comes earlier in the text.
Here are some commands for manipulating the mark:

<definition_list>
<deflist_item>(^@ or Select (set-mark))
<x>(^@)
<x>(LK201 Select)
<x>(set-mark)
<deflist_def>
Sets the mark at the location of dot.

<deflist_item>(^X-^X (exchange-dot-and-mark))
<x>(^X-^X)
<x>(exchange-dot-and-mark)
<deflist_def>
Exchanges dot and mark.

<deflist_item>(ESC-x region-around-match)
<x>(region-around-match)
<deflist_def>
Sets dot and mark around the most recently found string or string partition.

<deflist_item>(^X-^@ (unset-mark))
<x>(^X-^@)
<x>(unset-mark)
<deflist_def>
Deletes the current mark.

<enddefinition_list>

<x>(case-region-upper)
<p>
For example, if you want to convert part of the buffer to upper-case, you
can use the <key_name>(ESC-x case-region-upper) command, which operates on the
text in the region. You first go to the beginning of the text to be altered,
set the mark there, move to the end, and then type
<quote>(<cx>(ESC-x case-region-upper)).
Or, you can set the mark at the end of the text, move to the beginning,
and then type <quote>(<cx>(ESC-x case-region-upper)).

<p>
The most common way to set the mark is with the <key_name>(^@) or
<key_name>(Select) command. This sets the mark at the current location of
dot. You can then move dot away, leaving the mark behind.  The easiest way
to type the <key_name>(^@) command on Digital keyboards is to press and
hold the <key_name>(Ctrl) key and simultaneously press the
<key_name>(Space) bar.

<x>(highlight-region)
<p>
EMACS allows you to see the currently selected region on ANSI terminals by
highlighting the text between the mark and dot in buffers with the
<key_name>(highlight-region) variable set. For non-ANSI terminals,
EMACS has no way to show you where the mark is located, so you have
to remember its location. The usual solution to this problem is to set the
mark and then use it quickly, before you forget where it is.

<p>
You can always see where the mark is with the command <key_name>(^X-^X) which
puts the mark where dot is and dot where the mark was. The extent of the
region is unchanged, but the cursor and dot are now at the previous location
of the mark.

<p>
<key_name>(^X-^X) is also useful when you are satisfied with the location
of dot but want to move the mark; type <quote>(<cx>(^X-^X)) to put dot where
the mark currently is, then you can move it. A second use of
<key_name>(^X-^X), if necessary, puts the mark at the new location with
dot back at its original position.

<p>
The function <key_name>(region-around-match) can be used to set dot and mark
around any partition of the matched pattern. It expects one argument: 0
indicating the whole matched string, or a number <emphasis>(n\italic)
indicating the <emphasis>(n\italic)'th partitioned regular expression.
See <reference>(regexpsearch_sec) for more information on regular
expression searching.

<p>
If you have set a mark and wish to remove it, use the command
<key_name>(^X-^@). The mark is removed, and dot remains unchanged. This is
useful on ANSI terminals where a highlighted region may distract you when
you have finished with it.


<head1>(Deleting and Moving Text\delmovtxt_sec)

<p>
The commonest way to move or copy text in EMACS is to delete it, and then
restore it in one or more places.

<head2>(Text Deletion\txtdel_sec)

<p>
Most commands which erase text from the buffer save it somewhere so that
you can retrieve it if you change your mind, or if you want to  move or
copy it to other parts of the buffer. The delete commands that do not save
the text include <key_name>(^D) and <key_name>(Delete), which delete only
one character at a time, and those commands that delete only spaces or
line separators. Commands that can destroy significant amounts of
non-trivial data generally save the text. If you use any delete command by
mistake, you can use the <key_name>(^X-^U) command to undo it.  <x>(undo)
<x>(^X-^U)

<p>
The text deletion commands are:

<definition_list>
<deflist_item>(^D (delete-next-character))
<x>(^D)
<x>(delete-next-character)
<deflist_def>
Deletes the next character.

<deflist_item>(Delete (delete-previous-character))
<x>(Delete)
<x>(delete-previous-character)
<deflist_def>
Deletes the previous character.

<deflist_item>(^K (kill-to-end-of-line))
<x>(^K)
<x>(kill-to-end-of-line)
<deflist_def>
Deletes the rest of the line or one or more lines.

<deflist_item>(^W (delete-to-killbuffer))
<x>(^W)
<x>(delete-to-killbuffer)
<deflist_def>
Deletes the region.

<deflist_item>(ESC-d (delete-next-word))
<x>(ESC-d)
<x>(delete-next-word)
<deflist_def>
Deletes the next word.

<deflist_item>(ESC-h (delete-previous-word))
<x>(ESC-h)
<x>(delete-previous-word)
<deflist_def>
Deletes the previous word.

<enddefinition_list>

<p>
The most basic delete commands are <key_name>(^D) and <key_name>(Delete).
<key_name>(^D) deletes the character the cursor is over. The cursor does
not move. <key_name>(Delete) deletes the character before the cursor, and
moves the cursor back one character. Line separators act like single
characters when they are deleted.

<p>
The <key_name>(^W) command is a general delete command. This command
deletes everything between dot and mark. With this command, you can delete
any contiguous characters if you first set the mark at one end of the
character string, then move to the other end and use <key_name>(^W). The
deleted text is saved in a buffer called <quote>(<key_name>(Kill buffer)).

<p>
The simplest delete command is <key_name>(^K). If given at the beginning
of a line, it deletes all the text on the line leaving it blank. If given
on a blank line, the blank line is deleted. As a consequence, if you go to
the front of a non-blank line and type two <key_name>(^K)s, the line
disappears completely.

<p>
More generally, <key_name>(^K) deletes from dot up to the end of
the current line, unless it is at the end of a line. When dot is at the
end of a line, <key_name>(^K) deletes the line separator following the
line, thus joining the next line with the current line.

<p>
<key_name>(^K) moves the text it deletes into <key_name>(Kill buffer).
This is the same buffer that <key_name>(^W) uses, so <key_name>(^K) and
<key_name>(^W) cannot be used at the same time as each command erases the
data in <key_name>(Kill buffer) first. However, successive uses of the
<key_name>(^K) command add the newly-deleted data to the end of
<key_name>(Kill buffer) (the command only erases <key_name>(Kill buffer)
when the previous command was not a <key_name>(^K)). So, if you wish to
move a region to another place in the buffer without disturbing dot, use a
number of <key_name>(^K)s, or provide the <key_name>(^K) command with a
prefix argument.

<head2>(Un-deleting Text\undeltxt_sec)

<definition_list>
<deflist_item>(^Y (yank-from-killbuffer))
<x>(^Y)
<x>(yank-from-killbuffer)
<deflist_def>
Inserts the last deleted text.

<enddefinition_list>

<p>
Un-deleting is retrieving text which has been deleted. The usual way to
move or copy text is to delete it, then un-delete it one or more times.

<p>
The <key_name>(^Y) command inserts the entire contents of <key_name>(Kill
buffer) into the current buffer at the location of dot.

<head2>(Other Ways of Copying Text\othercopy_sec)

<x>(append-region-to-buffer)
<p>
Text is usually copied or moved by first deleting it and then un-deleting
it. There are other methods that are useful for copying one block of text
to many places, or for copying many scattered blocks of text into one
place.  You can accumulate blocks of text from scattered locations either
into a buffer or into a file.

<p>
To append blocks of text into a buffer, use the command <key_name>(ESC-x
append-region-to-buffer), which inserts a copy of the region into the
specified buffer at the location of dot in that buffer. If there is no
buffer with the name you specify, the buffer is created.

<p>
Dot in the specified buffer is left at the end of the copied
text, so successive uses of <key_name>(append-region-to-buffer)
accumulate the text in the specified buffer.

<x>(yank-buffer)
<p>
You can retrieve the accumulated text from that buffer with
<key_name>(ESC-x yank-buffer). This inserts a copy of the text in
the specified buffer into the current buffer. You can also
select the other buffer for editing.

<x>(append-to-file)
<p>
Rather than accumulating text in an EMACS buffer, you can append
text directly to a disk file with the command <key_name>(ESC-x
append-to-file). This command adds the text of the region to the end of the
specified file. The file is modified immediately on disk. This command is
normally used with files that are not being visited in EMACS.


<head1>(Commands for Fixing Typos\typos_sec)

<p>
This section describes commands that are especially useful
when you catch a mistake in your text just after you have made it, or
change your mind while composing.

<definition_list>
<deflist_item>(Delete (delete-previous-character))
<x>(delete-previous-character)
<x>(Delete)
<deflist_def>
Deletes the previous character.

<deflist_item>(ESC-h (delete-previous-word))
<x>(ESC-h)
<x>(delete-previous-word)
<deflist_def>
Deletes the previous word.

<deflist_item>(^T (transpose-characters))
<x>(^T)
<x>(transpose-characters)
<deflist_def>
Transposes the last two characters.

<deflist_item>(^X-^U (undo))
<x>(^X-^U)
<x>(undo)
<deflist_def>
Undoes the last sequence of commands that affected buffers.

<enddefinition_list>

<head2>(Deleting Your Mistakes\delmistake_sec)

<p>
The <key_name>(Delete) command is the most important correction
command. When used with self-inserting characters, it can
be thought of as cancelling the last character typed.

<p>
When your mistake is longer than a couple of characters, it
might be more convenient to use <key_name>(ESC-h). <key_name>(ESC-h)
deletes back to the start of the last word.

<p>
<key_name>(ESC-h) is often useful even when you have typed only a
few incorrect characters, or if you know you are confused in your
typing and are not sure exactly what you typed. In such cases,
you cannot correct with <key_name>(Delete) except by looking
at the screen to see what you did. It requires less thought
to delete the whole word and start over again, and is
quicker if the system is heavily loaded.

<head2>(Correcting Transposition Errors\transpos_sec)

<p>
The common error of transposing two characters can be corrected with the
<key_name>(^T) command when the characters are adjacent.
<key_name>(^T) transposes the two characters preceding dot, so if you
catch your transposition error right away, you can correct it
with a <key_name>(^T). If you do not catch it so quickly, you
must move the cursor back to the two transposed characters.
If you transposed a space with the last character of the
word before it, the word motion commands are a good way of
moving to the correct position.

<head2>(Case Conversion\advedit_caseconv_sec)
<x>(ESC-l)
<x>(ESC-u)
<x>(ESC-^)

<p>
A very common error is to type words in the wrong case.
As this is such a common error, the word case-conversion commands
<key_name>(ESC-l), <key_name>(ESC-u) and <key_name>(ESC-^) have a special
feature: they do not move the cursor. As soon as you see you have
mis-typed the last word, you can simply change its case and go on.
See <reference>(caseconv_sec) for details on using the case-conversion
commands.


<head1>(Advanced File Handling\advfile_sec)

<p>
The basic unit of stored data is the <newterm>(file). Each document lives
in its own file. To edit a  document, you must tell EMACS the name of the
file that contains it. This is called <newterm>(visiting) the file. To
make your changes to the file permanent on disk, you must <newterm>(save)
the file. EMACS also has facilities for deleting files conveniently.

<p>
For convenience, all file operation commands are prefixed with <key_name>(^X).

<head2>(Visiting Files\visitfile_sec)

<definition_list>

<deflist_item>(^X-^V (visit-file))
<x>(^X-^V)
<x>(visit-file)
<deflist_def>
Visits a file.

<deflist_item>(^X-^^-s (write-current-file))
<x>(^X-^^-s)
<x>(write-current-file)
<deflist_def>
Saves the current file to disk.

<enddefinition_list>

<p>
Visiting a file means copying the file into EMACS where you can edit it.
EMACS remembers the name of the file you visited. When you visit a file, a
new buffer is created for the file; the buffer name is derived from
the file name you visited. When you visit a file, the buffer containing
the file is displayed in one of the windows on the screen. If only a small
number of windows are currently displayed, a new window may be
created for the buffer. The fully-expanded name of the file you are
visiting is visible in the mode line when you are at top level.

<p>
The changes you make with EMACS are made to a copy of the file inside
EMACS, not to the file itself.  The changed text is not made permanent
until you save it in a file.  The first time you change the text, an
asterisk appears in the mode line. This indicates that the text contains
fresh changes which will be lost unless you save them.

<x>(^G)
<p>
To visit a file, use the command <key_name>(^X-^V). Follow the command
with the name of the file you wish to visit, terminated by a
<key_name>(Return). EMACS uses the standard VMS defaulting mechanism
when accessing files. You can abort the command while it is asking for a
file name by typing <key_name>(^G); you can also edit the filename with the
standard editing commands. File name completion is enabled.  See
<reference>(completion_sec) for more information on name completion.

<p>
When you wish to save the file and make your changes permanent, type
<key_name>(^X-^^-s).  After the save is finished, <key_name>(^X-^^-s)
prints <quote>(<cx>(Wrote: <emphasis>(filename\italic))) in the
Mini-buffer, where <cx>(<emphasis>(filename\italic)) is the name of the
file written.

<p>
If you want to create a file, just visit it. EMACS prints
<quote>(<cx>(New File: <emphasis>(filename\italic))) in the Mini-buffer,
but apart from that, behaves exactly as if you had visited an
existing empty file. If you make any changes and save them,
the file is created. If you visit a non-existent file
unintentionally (because you typed the wrong file name), go
ahead and visit the file you meant to visit. If you do not modify or
save the unwanted file, it is not created.

<p>
If you visit one file and then visit another which would use
the same buffer name, EMACS asks you what buffer to use for
the new file. You can answer with a <key_name>(Return), and the
old buffer's contents will be destroyed, or you can type the
name of a buffer to use.

<x>(ask-about-buffer-names)
<p>
You can also set the variable <key_name>(ask-about-buffer-names) so
that EMACS automatically appends a sequence number to the buffer used. For
example, if you visit file A.B, EMACS creates buffer <key_name>(a.b).
With <key_name>(ask-about-buffer-names) set to 1, if you then visit file
SYS$SYSTEM:A.B, EMACS will use buffer
<key_name>(a.b<literal>(<)2<literal>(>))), and so on.


<head2>(Miscellaneous File Operations\miscfile_sec)

<p>
EMACS has extended commands for performing many other operations on files.

<definition_list>
<deflist_item>(ESC-x view-file)
<x>(view-file)
<deflist_def>
Scans or reads a file by sequential screen-fulls without
visiting the file. It enters a subsystem in which you type
a <key_name>(Space) to see the next screen-full, or a
<key_name>(Backspace) to see the previous screen-full. Typing any other
character exits the command.

<deflist_item>(^X-^W (write-named-file))
<x>(^X-^W)
<x>(write-named-file)
<deflist_def>
Writes the contents of the current buffer into the file
specified, and then visits that file. This can be thought of
as a way of changing the name of the file you are visiting.

<deflist_item>(^X-^I (insert-file))
<x>(insert-file)
<x>(^X-^I)
<deflist_def>
Inserts the contents of the specified file into the buffer
at dot, leaving dot at the beginning of the inserted text.

<deflist_item>(ESC-x append-to-file)
<x>(append-to-file)
<deflist_def>
Appends  the  current buffer  to  a nominated file.

<deflist_item>(ESC-x unlink-file)
<x>(unlink-file)
<deflist_def>
Deletes the specified file.

<deflist_item>(^X-^M (write-modified-files))
<x>(write-modified-files)
<x>(^X-^M)
<deflist_def>
Writes all file buffers that have been modified since they
were last visited and deletes the appropriate checkpoint and/or journal files.

<deflist_item>(^X-^F (write-file-exit))
<x>(write-file-exit)
<x>(^X-^F)
<deflist_def>
Writes all file buffers that have been modified and then
exits EMACS (or a recursive edit level).

<enddefinition_list>

<x>(current-buffer-file-name)
<p>
The variable <key_name>(current-buffer-file-name) contains the name
of the file to which the current buffer is associated (if
there is one). You can change the name by setting this
variable to the required file name.


<head2>(Protection Against Disasters\disaster_sec)

<p>
EMACS offers two features that protect against losing changes to files that you
are editing. These features are called checkpointing and journalling.

<x>(Checkpointing)
<p>
When <newterm>(checkpointing) is enabled, EMACS saves your buffers from
time-to-time when a certain number of keystrokes have been made. The
buffers are written automatically, but you can also force EMACS to
checkpoint at any time you wish. Checkpointing prevents you from losing
more than a limited amount of work when a disaster occurs.

<p>
When <newterm>(journalling) is enabled, EMACS saves all the insertions and
deletions made to your buffers in a <newterm>(journal file).  The changes
are saved to the journal file at the same time as you make them to the
proper file.

<p>
Each method has its advantages and disadvantages. You will notice that
it can take a long time to write the checkpoint file for a large file,
since EMACS writes out the whole file every time it checkpoints. On the
other hand, journalling only writes out the changes that you have made,
which is much faster.

<p>
Journalling is at a disadvantage  when you  use complex commands
which make many changes to the buffer. When this happens,
many journal records must be written to the journal file.

<head3>(Protection Against Disasters Using Checkpointing\checkpointing_sec)

<x>(current-buffer-checkpointable)
<x>(checkpoint-frequency)
<p>
If you want EMACS to checkpoint, you must set the variable
<key_name>(checkpoint-frequency) to the number of keystrokes you want to strike
between checkpoints. If <key_name>(checkpoint-frequency) is zero,
checkpointing is disabled for all buffers. When EMACS starts up,
checkpointing is set to occur every 300 keystrokes.

<p>
Each time you visit a file, no matter how, checkpointing is turned on for
the created buffer if <key_name>(checkpoint-frequency) is non-zero. Once you
have visited a file, you can turn checkpointing on or off by setting
the variable <key_name>(current-buffer-checkpointable) to 1 or 0.
You can tell if a buffer has checkpointing switched on and if
checkpointing is enabled as the minor mode string
<quote>(<cx>(Checkpoint)) will be displayed in the buffer's mode line.

<x>(Activity indicator)
<p>
If a checkpoint occurs while the activity indicator is being used, the
checkpoint activity is indicated by a <quote>(<cx>(c)) in the bottom-left
hand corner of the screen. When the checkpoint is complete, this will
change back to the character displayed before the checkpoint started.

<p>
When a checkpoint occurs and the activity indicator is switched off,
<quote>(<cx>(Checkpointing...)) is printed in the Mini-buffer. When all
modified files have been checkpointed, EMACS displays
<quote>(<cx>(Checkpointing... done.)) If an error is detected during the
checkpoint, <quote>(<cx>(error.)) is displayed instead of <quote>(<cx>(done.))

<x>(checkpoint-buffers)
<x>(checkpoint-hook)
<p>
The action of saving each modified buffer occurs because the default
checkpoint action is to call the function <key_name>(checkpoint-buffers).
When checkpointing runs, it calls the function whose name is in the variable
<key_name>(checkpoint-hook).  The default value for
<key_name>(checkpoint-hook) is the function <key_name>(checkpoint-buffers).

<p>
<key_name>(checkpoint-buffers) writes each buffer to its own checkpoint
file. The file used has the same file name as the buffer name with an
extension of <quote>(<cx>(.CKP)) All checkpoint files are written to the
default directory by default.  For non-file buffers, the buffer name is
used and the extension <quote>(<cx>(.CKP)) is added to make a file name;
if this results in a file name with incorrect syntax,
<quote>(<cx>(CHECKPNT.CKP)) is used as the file name.

<x>(EMACS$CHECKPOINT)
<p>
If you do not want checkpoint files written to the default directory, you
can define the logical name EMACS$CHECKPOINT as the location for your
checkpoint files.  If this logical name is defined before EMACS is
started, EMACS will write all checkpoint files to this directory rather
than to the default directory.

<p>
When it is time to recover files after a system crash, simply rename the
checkpoint files to their original file names.

<x>(unlink-checkpoint-files)
<p>
EMACS deletes a checkpoint file whenever the proper file is saved. It also
deletes checkpoint files when EMACS exits if the variable
<key_name>(unlink-checkpoint-files) is set.

<head3>(Protection Against Disasters Using Journalling\journalling_sec)

<x>(current-buffer-journalled)
<x>(journal-frequency)
<p>
If you want EMACS to journal, you must set the variable
<key_name>(journal-frequency) to the number of seconds you want EMACS to
wait before writing out journal records.  If <key_name>(journal-frequency)
is zero, journalling is disabled for all buffers. When EMACS starts
up, checkpointing is enabled and journalling is disabled.

<p>
Each time you visit a file, no matter how, journalling is turned on for
the created buffer if <key_name>(journal-frequency) is non-zero. Once you
have visited a file, you can turn journalling on or off by setting
the <key_name>(current-buffer-journalled) variable. You can tell if a
buffer has journalling switched on and whether journalling is enabled as
the mode line for the buffer will contain the minor mode string
<quote>(<cx>(Journal)).

<x>(Activity indicator)
<p>
If journalling is writing to the journal file and the activity indicator
is being used, the journal activity is indicated by a <quote>(<cx>(j)) in
the bottom left hand corner of the screen. When the journalling is
complete, this will change back to the character displayed before the
journalling started.  However, it is rare that you will see the
<quote>(<cx>(j)), because journalling is very fast.

<x>(journal-recover)
<p>
When it is time to recover files after a system crash, simply use the
<key_name>(journal-recover) command, specifying the name of the journal
file to recover.

<p>
All the  journal  files that EMACS writes are kept in the directory
EMACS$JOURNAL: For each buffer that had journalling enabled and had not
been saved, there will be a journal file in EMACS$JOURNAL:.

<p>
For buffers  with  associated files, the journal name will be based on the
file name.  For example, the file LOGIN.COM will have a journal
file named LOGIN.COM_EMACS_JOURNAL.

<p>
For buffers  without  associated  files, the journal has a slightly
different  name.   For  example, the buffer <key_name>(Kill buffer) will
have a journal called <hyphenate>(KILL_BUFFER.\BUFFER_EMACS_JOURNAL).

<p>
<key_name>(journal-recover) prompts  for  the  name of the journal
file, which must be in EMACS$JOURNAL:.  EMACS will check that the
journal file is  valid  before attempting to apply it.  For a file, EMACS
checks that the version number of the file is the same as the journal was
recorded  for.  For a buffer, EMACS checks that the buffer does not exist.
These  checks  ensure  that using <key_name>(journal-recover) will not
damage your data.

<p>
EMACS deletes a journal file whenever the proper file is saved. Journal
files are also deleted when EMACS exits.

<head2>(Editing Stream Files\streamfiles_sec)

<x>(Stream files<xs>Editing)
<x>(Macintosh files<xs>Editing)
<x>(MS-DOS files<xs>Editing)
<x>(PC files<xs>Editing)
<x>(Unix files<xs>Editing)

<p>
Most text files created on VMS are sequential, variable length record
files. Text files created on other operating systems such as Unix, MS-DOS
or the Macintosh Operating System are not record-oriented---they are
created as <newterm>(stream files), where the data is stored as a continuous
stream of bytes.

<p>
As with most VMS text editors, EMACS can read and write record-oriented
files.  EMACS is also able to directly read and write stream files created
on operating systems other than VMS.  Other VMS text editors are not
usually able to edit stream files directly, since they expect
record-oriented files.  To edit a stream file with VAX LSE, for example,
you would first need to convert it to a record-oriented file.  With EMACS,
the conversion is not necessary.

<p>
EMACS uses the following variables to support the editing of stream files:

<definition_list>

<deflist_item>(current-buffer-RMS-record-attribute)
<x>(current-buffer-RMS-record-attribute)
<deflist_def>
A buffer-specific variable containing a string value describing the record
format of the file associated with the current buffer.

<deflist_item>(default-buffer-RMS-record-attribute)
<x>(default-buffer-RMS-record-attribute)
<deflist_def>
Contains a string value indicating the record format in which new files
written by EMACS should be created.

<deflist_item>(override-RMS-record-attribute)
<x>(override-RMS-record-attribute)
<deflist_def>
Contains a string value describing the format in which to write out all
new files, overriding the setting of
<key_name>(current-buffer-RMS-record-attribute).  The default value is to
not override.

<enddefinition_list>

<x>(current-buffer-RMS-record-attribute)
<p>
Every buffer created by EMACS is assigned the buffer-specific variable
<key_name>(current-buffer-RMS-record-attribute).  This variable contains a
string value which describes the RMS attribute of the file associated
with each buffer.  When EMACS visits an existing file, it retrieves the
file's record attribute and sets the
<key_name>(current-buffer-RMS-record-attribute) variable accordingly.  The
values that this variable can take are described in
<reference>(RMSattributes_tab).

<table>(Supported RMS Record Attributes\RMSattributes_tab)
<table_attributes>(keep)
<table_setup>(2\22)
<table_heads>(current-buffer-RMS-record-attribute\File Type)
<table_row>(variable\	VMS text files)
<table_row>(stream\	MS-DOS stream files)
<table_row>(stream-lf\	Unix stream files)
<table_row>(stream-cr\	Macintosh stream files)
<endtable>

<p>
When EMACS writes a buffer out to a file, the new file is created with the
record attribute described by the
<key_name>(current-buffer-RMS-record-attribute) variable.

<x>(default-buffer-RMS-record-attribute)
<p>
When you visit a new file, EMACS uses the
<key_name>(default-buffer-RMS-record-attribute) variable to set the
equivalent buffer-specific variable.  The default value is
<key_name>(variable), indicating that new files should be created with
standard RMS variable length records.

<x>(override-RMS-record-attribute)
<p>
You can override the setting of
<key_name>(current-buffer-RMS-record-attribute) and force files to be
written in a particular format by setting the
<key_name>(override-RMS-record-attribute) variable.  The default setting
for this variable is <key_name>(none), which means do not override.  You
can set <key_name>(override-RMS-record-attribute) to any of the supported
record attributes listed in <reference>(RMSattributes_tab).  For example,
to force all files to be written in <key_name>(stream-lf) format, use the
following code:

<online_popup>(example)
<code_example>
(setq override-RMS-record-attribute "stream-lf")
<endcode_example>
<endonline_popup>


<head1>(Controlling the Display\controldisp_sec)

<p>
Since only part of a large buffer can fit on the screen, EMACS
tries to show the part of the buffer that is likely to be most
interesting. The display control commands allow you to tell EMACS that you
want to see a different part of the buffer.

<definition_list>
<deflist_item>(^L (redraw-display))
<x>(^L)
<x>(redraw-display)
<deflist_def>
Clears  and  re-displays the  screen.

<deflist_item>(^Z (scroll-one-line-up))
<x>(^Z)
<x>(scroll-one-line-up)
<deflist_def>
Scrolls forward one line.

<deflist_item>(ESC-z (scroll-one-line-down))
<x>(ESC-z)
<x>(scroll-one-line-down)
<deflist_def>
Scrolls backward one line.

<deflist_item>(ESC-! (line-to-top-of-window))
<x>(ESC-!)
<x>(line-to-top-of-window)
<deflist_def>
Moves the line in which dot is located to the top of the
current window.

<deflist_item>(ESC-x scroll-one-column-left)
<x>(scroll-one-column-left)
<deflist_def>
Scrolls one column from the left-hand side of the screen.

<deflist_item>(ESC-x scroll-one-column-right)
<x>(scroll-one-column-right)
<deflist_def>
Scrolls one column from the right-hand side of the screen.

<deflist_item>(ESC-@ (column-to-left-of-window))
<x>(column-to-left-of-window)
<x>(ESC-@)
<deflist_def>
Scrolls the current column to the left of the screen.

<deflist_item>(^V or Next Screen (next-page))
<x>(^V)
<x>(LK201 Next Screen)
<x>(next-page)
<deflist_def>
Moves to the next page.

<deflist_item>(ESC-v or Prev Screen (previous-page))
<x>(ESC-v)
<x>(LK201 Prev Screen)
<x>(previous-page)
<deflist_def>
Moves back a page.

<enddefinition_list>


<p>
The terminal screen is rarely large enough to display all of your file. If
the whole buffer does not fit on the screen, EMACS displays a contiguous
portion of the buffer which always contains dot. EMACS continues to display
approximately the same portion of the buffer until dot moves outside of
the displayed portion; EMACS then chooses a new portion centred around the
new location of dot. This is EMACS' guess as to what you are most
interested in seeing.  If EMACS' guess is wrong, you can use the display
control commands to see a different portion. The finite area of screen
through which you can see part of the buffer is called a
<newterm>(window). EMACS can display many windows on the screen; the
maximum number of displayable windows is determined by the number of lines
on the screen.

<x>(scroll-step)
<p>
When EMACS chooses a new window position, it always tries to
place dot half-way down the buffer's window. This is
controlled by the variable <key_name>(scroll-step), whose value is the
number of lines to automatically move the window. However, if the end of
the buffer is on the screen, EMACS tries to leave as little as possible of
the screen blank beneath it, so that the screen space is not wasted.

<p>
The basic display control command is <key_name>(^L). This command
clears the screen and re-draws it from internal information.

<p>
The vertical scrolling commands <key_name>(^Z) and <key_name>(ESC-z)
let you move a whole window up or down a few lines.
<key_name>(^Z) with an argument shows you the specified number of lines at
the bottom of the window, moving the text but not moving dot unless it
moves out of the window. <key_name>(^Z) with a negative argument shows you
more lines at the top of the window, as does <key_name>(ESC-z) with a
positive argument.

<p>
The horizontal scrolling commands let you move the whole window left or
right by a few columns. This lets you view buffers with lines that are
longer than your screen's width.  The most useful of these commands is
<key_name>(column-to-left-of-window). You can move dot in a line until you
decide where the new left-hand side of the screen should be,  then use the
<key_name>(ESC-@) command to move the window to the selected column. When
you want the window back to the left side of the buffer, go to the
beginning of the line with <key_name>(^A) and use
<key_name>(column-to-left-of-window) again.

<p>
To read the buffer a window-full at a time, use the
<key_name>(^V) or <key_name>(Next Screen) command with no argument. This moves
the start of the window 4/5th's of a screen further down the buffer. Dot
will remain where it was unless it moves out of the window.
Thus, each <key_name>(^V) command displays the next window-full, except for
two lines of overlap to provide continuity. To move
backward, use <key_name>(ESC-v) without an argument, which moves a
window-full backwards.

<x>(view-mode Return)
<p>
Scanning by screen-fulls through the buffer for some
distance is most conveniently done with the <key_name>(ESC-x view-buffer)
command. This command enters a simple subsystem in which
<key_name>(Space) moves a screen-full forward and <key_name>(Backspace)
moves a screen-full backward. The <key_name>(Return) character exits,
leaving dot centred in whatever part of the buffer was visible. Any other
character exits and returns dot to its former location, and is then
executed as a command. <key_name>(view-buffer) can be used to view another
buffer by giving the buffer's name as a string argument.


<head1>(Using Multiple Buffers\multibuf_sec)

<p>
EMACS can contain a large number of buffers, each containing text. At any
time, only one buffer can be selected and available for editing, but it is
not difficult to switch to a different buffer. Each buffer individually
remembers which file it is visiting, which modes are enabled, and whether
there are any changes that need saving. Buffer manipulation commands are
all prefixed with <key_name>(^X).

<definition_list>
<deflist_item>(^X-b (switch-to-buffer))
<x>(^X-b)
<x>(switch-to-buffer)
<deflist_def>
Selects or creates a buffer in the current window.

<deflist_item>(^X-^B (list-buffers))
<x>(^X-^B)
<x>(list-buffers)
<deflist_def>
Lists the existing buffers.

<deflist_item>(ESC-x delete-buffer)
<x>(delete-buffer)
<deflist_def>
Deletes the nominated buffer.

<deflist_item>(ESC-x pop-to-buffer)
<x>(pop-to-buffer)
<deflist_def>
Switches to the specified buffer using a different window.
<enddefinition_list>

<p>
Each buffer in EMACS has a single name which normally does
not change. A buffer's name can be any length. The name of a
buffer, and the name of the file visited in it, are visible
in the mode line when you are at top level.


<head2>(Creating and Selecting Buffers\cresel_buf)

<p>
To create a new buffer, you need only think of a name for it
(say, <quote>(<cx>(FOO))) and then type
<quote>(<cx>(^X-b FOO))
which is the command <key_name>(^X-b) followed by the buffer name. This
makes a new, empty buffer and selects it for editing. The
new buffer is not visiting any file and is called a
<newterm>(scratch) buffer. Each buffer has its own major mode; a new
buffer's major mode is always Normal Mode.

<p>
To return to buffer <quote>(<cx>(FOO)) later after having switched to
another buffer, the same command <quote>(<cx>(^X-b FOO)) is used, since
<key_name>(^X-b) can tell whether or not a buffer named <quote>(<cx>(FOO))
already exists.

<p>
<key_name>(^X-b) changes the buffer associated with the current window.
You can use <key_name>(ESC-x pop-to-buffer) to use another window and
select a new buffer.

<head2>(Using Existing Buffers\existbuf_sec)

<p>
To get a list of all existing buffers, type <key_name>(^X-^B). Each
buffer's name, size in characters, buffer type (<quote>(<cx>(Scr)) for
scratch, <quote>(<cx>(File)) for file and <quote>(<cx>(Macro))
for macro), major and minor modes, and visited file are all displayed. An
<quote>(<cx>(M))  indicates a modified buffer which contains changes
that have not been saved.  <quote>(<cx>(C)), <quote>(<cx>(A)) and
<quote>(<cx>(R)) indicate that checkpointing, Abbreviation
Mode and replace mode are in effect for the buffer.

<x>(current-buffer-name)
<p>
The variable <key_name>(current-buffer-name) contains the name of
the currently selected buffer, and can be set to change the name of the
buffer. Name collisions are detected and an error message is generated
when such collisions occur.

<x>(append-region-to-buffer)
<x>(yank-buffer)
<p>
The commands <key_name>(ESC-x append-region-to-buffer) and
<key_name>(ESC-x yank-buffer) can be used to copy text from one buffer
to another. See <reference>(delmovtxt_sec) for details on deleting and
moving text.

<head2>(Deleting Buffers\delbuf_sec)

<p>
After you use an EMACS session for a while, it may fill up with buffers
which you no longer need. Eventually, you can reach a point where trying to
create any more buffers results in an error message.

<p>
You can delete buffers using the <key_name>(ESC-x delete-buffer) command.
If you delete the current buffer in any way, EMACS will automatically
select a new buffer as the current buffer.
If other buffers are displayed on the screen, EMACS
will select one of these buffers and will make it the current buffer.
If you delete the last exisiting buffer, EMACS will automatically create a
buffer called <key_name>(main) and will make <key_name>(main) the current
buffer.

<p>
If you attempt to delete a buffer that has un-saved modifications, EMACS
asks you to verify that you wish to discard the changes you have made.

<head1>(Using Multiple Windows\multiwin_sec)

<p>
EMACS allows you to split the screen into many windows and use them to
display parts of any buffer. The number of windows that can be fitted on
the screen is dependent on the number of lines on the displaying terminal.
Each window must be at least two lines long, one line for the text portion and
the other line for the window's mode line. So, for a 24-line VT220 terminal,
the maximum number of displayable windows is 11.

<p>
The following commands are available for manipulating
windows:

<definition_list>
<deflist_item>(^X-2 (split-current-window))
<x>(^X-2)
<x>(split-current-window)
<deflist_def>
Horizontally splits the current window into two windows.

<deflist_item>(^X-3 (split-current-window-vertically))
<x>(^X-3)
<x>(split-current-window-vertically)
<deflist_def>
Vertically splits the current window into two windows.

<deflist_item>(^X-1 (delete-other-windows))
<x>(^X-1)
<x>(delete-other-windows)
<deflist_def>
Removes all other windows.

<deflist_item>(^X-n (next-window))
<x>(^X-n)
<x>(next-window)
<deflist_def>
Moves dot to the window below the current window.

<deflist_item>(^X-p (previous-window))
<x>(^X-p)
<x>(previous-window)
<deflist_def>
Moves dot to the window above the current window.

<deflist_item>(^X-z (enlarge-window))
<x>(^X-z)
<x>(enlarge-window)
<deflist_def>
Enlarges the current window.

<deflist_item>(^X-^Z (shrink-window))
<x>(^X-^Z)
<x>(shrink-window)
<deflist_def>
Shrinks the current window.

<deflist_item>(ESC-x narrow-window)
<x>(^X-z)
<x>(narrow-window)
<deflist_def>
Reduces the width of the current window.

<deflist_item>(ESC-x widen-window)
<x>(^X-^Z)
<x>(widen-window)
<deflist_def>
Increases the width of the current window.

<deflist_item>(^X-d (delete-window))
<x>(^X-d)
<x>(delete-window)
<deflist_def>
Deletes the current window.

<deflist_item>(ESC-^V (page-next-window))
<x>(ESC-^V)
<x>(page-next-window)
<deflist_def>
Scrolls the  window below the current window.

<enddefinition_list>

<x>(split-current-window)
<p>
The command <key_name>(^X-2) divides the current window into two
equally-sized windows. The two windows will be connected to
the same buffer, so that the text of that buffer around dot
will be displayed in both windows.

<p>
<key_name>(^X-3) also divides the current window into two
equally-sized windows, but the two windows are placed side-by-side
instead of one above the other as is done by <key_name>(^X-2).

<p>
To return to viewing only one window, use the command
<key_name>(^X-1). The current window expands to fill the whole screen,
and all other windows disappear.

<p>
<key_name>(^X-d) deletes the current window and re-positions dot
in the window directly above. If only one window is on the
screen, buffer <key_name>(Main) is popped onto the screen.

<p>
While you have more than one window displayed on the screen, you can use
<key_name>(^X-n) and <key_name>(^X-p) to switch between windows. If
you attempt to move to the next window from the last window
on the screen, EMACS considers the next window to be the window
at the top of the screen.  Similarly, if you attempt to move to the
previous window when dot is in the top window, EMACS moves dot to the
bottom window.

<p>
If the current buffer and window is the Mini-buffer at the
bottom of the screen, then this window, too, is considered
to be in the <newterm>(ring) of windows displayed on the screen.

<p>
Often you will be editing one window while using another
just for reference. The command <key_name>(ESC-^V) is very
useful in such cases---it scrolls the next window without switching to it
and switching back. It scrolls the same way <key_name>(^V) does:
with no argument, 4/5th's  of the window up; with an argument
<emphasis>(n\italic), <emphasis>(n\italic) pages up (or down when
<emphasis>(n\italic) is negative).

<x>(enlarge-window)
<x>(shrink-window)
<x>(^X-z)
<x>(^X-^Z)
<p>
When you split a window, the space for the old window will be divided
evenly between the two windows. You can redistribute screen space
between the windows with the <key_name>(^X-z) and <key_name>(^X-^Z)
commands. These make the currently selected window become one line bigger
or smaller respectively (or as many lines as is specified with a numeric
argument).


<head1>(Narrowing\narrowing_sec)

<p>
<newterm>(Narrowing) means focussing-in on one portion of a
buffer, making the rest of the buffer temporarily invisible and
inaccessible.

<definition_list>
<deflist_item>(ESC-x narrow-region)
<x>(narrow-region)
<deflist_def>
Narrows down to the region between dot and mark.

<deflist_item>(ESC-x widen-region)
<x>(widen-region)
<deflist_def>
Widens to view the entire buffer.

<enddefinition_list>

<p>
When you have narrowed down to a part of the buffer, the narrowed part
appears to be all there is. You cannot see the rest of the buffer;
you cannot move into it, since motion commands will not move outside of
the narrowed part; you cannot change it in any way. However, it has not
been deleted, and if you save the file, all the invisible text will be
saved.

<p>
Narrowing can be used to concentrate on a single subroutine or paragraph
by eliminating clutter.  Narrowing is also useful when you want to
restrict the range of operation of commands such as replace commands.

<x>(narrow-region)
<p>
The primary narrowing command is <key_name>(ESC-x narrow-region).
It sets the virtual buffer boundaries at dot and mark, so
that only the text that was between dot and mark remains accessible. Dot and
mark do not change.

<x>(widen-region)
<p>
Use the <key_name>(ESC-x widen-region) command to remove the narrowing.
This makes all the text in the buffer accessible again.


<head1>(Searching\searching_sec)

<p>
Like other text editors, EMACS has commands that search for an
occurrence of a text string. The EMACS search commands are unusual in
that they can be normal text searches or regular expression pattern
matches.

<p>
Regular expression searching allows complex patterns to be
specified and searched for, with the ability to partition
matched strings for later reference and substitution.

<p>
The ordinary searching commands are:

<definition_list>
<deflist_item>(^^-s or GOLD-Find (search-forward))
<x>(^^-s)
<x>(LK201 GOLD-Find)
<x>(search-forward)
<deflist_def>
Searches forward.

<deflist_item>(^R (search-reverse))
<x>(^R)
<x>(search-reverse)
<deflist_def>
Searches backward.

<enddefinition_list>

<p>
<key_name>(^^-s) and <key_name>(GOLD-Find) prompt for a string, and
search through the buffer starting at dot for the specified string. If no
string is specified, <key_name>(search-forward) searches for the
next occurrence of the last search string.

<x>(case-fold-search)
<p>
Generally, EMACS looks for the string exactly as you typed
it. So, if you search for <quote>(<cx>(FOO)) then <quote>(<cx>(FOO)) in the
text will match, but <quote>(<cx>(Foo)) or <quote>(<cx>(foo)) will not.
However, if you set the variable <key_name>(case-fold-search) to 1,
all searches will make upper- and lowercase letters appear the same.

<head2>(Regular Expression Searching\regexpsearch_sec)

<p>
Regular expression searching provides a powerful pattern-matching facility
with optional partitioning of the pattern for later substitution.

<p>
The regular expression search commands are:

<definition_list>
<deflist_item>(ESC-x re-search-forward)
<x>(re-search-forward)
<deflist_def>
Searches for a pattern match forwards.

<deflist_item>(ESC-x re-search-reverse)
<x>(re-search-reverse)
<deflist_def>
Searches for a pattern match backwards.

<enddefinition_list>

<p>
Both these commands expect a regular expression pattern
for which to search. The pattern is interpreted and matched
against text according to the following rules:

<list>(numbered)
<le>
Any character except a special character matches
itself. Special characters are <quote>(<cx>(<literal>(\))), <quote>(<cx>([)),
<quote>(<cx>(.)) and sometimes <quote>(<cx>(^)), <quote>(<cx>(*)) and
<quote>(<cx>($)).

<le>
A <quote>(<cx>(.)) matches any character except newline.

<le>
A <quote>(<cx>(<literal>(\))) followed by any character except those
mentioned in the following rules matches that character.

<le>
A <quote>(<cx>(<literal>(\)w)) matches any word character, as defined in
the current buffer's syntax table.

<le>
A <quote>(<cx>(<literal>(\)W)) matches any non-word character, as defined
in the current buffer's syntax table.

<le>
A <quote>(<cx>(<literal>(\)b)) matches at a boundary between a word and
non-word characters, as defined in the current buffer's syntax table.

<le>
A <quote>(<cx>(<literal>(\)B)) matches anywhere but at a boundary between
a word and non-word characters, as defined in the current buffer's
syntax table.

<le>
A <quote>(<cx>(<literal>(\)`)) matches at the beginning of the buffer.

<le>
A <quote>(<cx>(<literal>(\)')) matches at the end of the buffer.

<le>
A <quote>(<cx>(<literal>(\<))) matches anywhere before dot.

<le>
A <quote>(<cx>(<literal>(\>))) matches anywhere after dot.

<le>
A <quote>(<cx>(<literal>(\)=)) matches at dot.

<le>
A non-empty string <cx>(s) bracketed <quote>(<cx>([s])) (or
<quote>(<cx>([^s]))) matches any character in (or not in) <cx>(s).  In
<cx>(s), <quote>(<cx>(<literal>(\))) has no special meaning, and
<quote>(<cx>(])) may only appear as the first letter. A subrange
<quote>(<cx>(a-z)), with <cx>(a) and <cx>(z) in ascending ASCII order,
stands for the inclusive range of ASCII characters.

<le>
A <quote>(<cx>(<literal>(\))) followed by a digit
<cx>(n) matches a copy of the string that the bracketed
regular expression beginning with the <cx>(n)th
<quote>(<cx>(<literal>(\)<oparen>)) matched.

<le>
A regular expression of one of the preceding forms
followed by <quote>(<cx>(*)) matches a sequence of zero or more
matches of the regular expression.

<le>
A regular expression, <cx>(x), bracketed
<quote>(<cx>(<literal>(\)<oparen>x<literal>(\)<cparen>))
matches what <cx>(x) matches. The matched string is
available for use in rule 14, as insertion text in regular
expression replace commands, or as an argument to the
<key_name>(region-around-match) function. The maximum number of
partitioned strings is 5.

<le>
A regular expression of this or one of the preceding
forms, <cx>(x), followed by a regular expression of one of
the preceding forms, <cx>(y), matches a match for <cx>(x)
followed by a match for <cx>(y) with the match for <cx>(x)
being as long as possible while still permitting a <cx>(y)
match.

<le>
A regular expression of one of the preceding forms
preceded by <quote>(<cx>(^)) is constrained to matches that begin at
the left-hand end of a line.

<le>
A regular expression of one of the preceding forms
followed by <quote>(<cx>($)) is constrained to matches that end at
the right-hand end of a line.

<le>
A sequence of regular expressions of one of the
preceding forms separated by <quote>(<cx>(<literal>(\|))) matches any one of
the regular expressions. The maximum number of alternative
strings is 10.

<le>
A regular expression of one of the preceding forms
picks out the longest amongst the left-most matches if
searching forward or the right-most if searching backward.

<le>
An empty regular expression stands for a copy of the
last regular expression encountered.
<endlist>

<x>(looking-at)
<p>
The function <key_name>(looking-at) returns 1 or 0 depending on
whether the specified regular expression follows dot.


<head1>(Replacement Commands\replace_sec)

<p>
EMACS has a normal text replacement function similar to that found in
most text editors.  EMACS also has a query replace operation which asks
you, for each occurrence of the search string, whether or not to replace it.
EMACS also allows you to use regular expressions in replace commands.

<x>(replace-string)
<p>
To replace every instance of <quote>(<cx>(FOO)) after dot with
<quote>(<cx>(BAR)), you can type <quote>(<cx>(ESC-r FOO BAR)).
This runs the function <key_name>(replace-string). Replacement
occurs only after dot, so if you want to cover the whole
buffer you must go to the beginning of the buffer first. Replacement
continues to the end of the buffer, but you can restrict the scope of the
replace command using narrowing.  See <reference>(narrowing_sec) for
details on narrowing commands.

<x>(replace-case)
<p>
Unless the variable <key_name>(replace-case) is zero, <key_name>(ESC-r)
tries to preserve case. For example, if you give both <quote>(<cx>(foo))
and <quote>(<cx>(bar)) in lower case, and if a particular
<quote>(<cx>(FOO)) is found with a capital initial or all capitalised, the
<quote>(<cx>(BAR)) which replaces it will be given the same case pattern.
Thus, <quote>(<cx>(ESC-r foo bar)) would replace <quote>(<cx>(foo)) with
<quote>(<cx>(bar)), <quote>(<cx>(Foo)) with <quote>(<cx>(Bar)) and
<quote>(<cx>(FOO)) with <quote>(<cx>(BAR)). If <key_name>(replace-case) is
zero, the replacement string is inserted with the case you used when you
typed it.

<x>(case-fold-search)
<p>
If <key_name>(case-fold-search) is zero, the string to be replaced
is found only when it has the same case as the string you typed.

<head2>(Query Replace\qeryrepl_sec)

<p>
If you want to change only some of the occurrences of a
string but not all, you cannot use an ordinary
replace command. Instead, use <key_name>(ESC-q). This displays each
occurrence of the matched pattern and waits for you to confirm
whether or not you want to replace it. The characters you can type when you
are shown an occurrence of the original string are:

<definition_list>
<deflist_item>(Space)
<deflist_def>
Replaces the string.

<deflist_item>(n)
<deflist_def>
Skips to the next match without replacing this match.

<deflist_item>(Comma)
<deflist_def>
Replaces this match and displays the result. You are then
asked for another input character. Since the replacement has
already been made, <key_name>(Delete) and <key_name>(Space) are
equivalent.

<deflist_item>(^G)
<deflist_def>
Exits the query replace command without doing any more replacements.

<deflist_item>(Period)
<deflist_def>
Replaces this match, then stops the query replace command.

<deflist_item>(!)
<deflist_def>
Replaces all remaining matches without asking for further confirmations.

<deflist_item>(r)
<deflist_def>
Enters a recursive editing level so that you can
edit the occurrence rather than just replace it. When you are done, exit
the recursive editing level with <key_name>(^C) and the next
occurrence will be located.

<enddefinition_list>

<p>
Any other character solicits a help display to remind you of the
available options.

<head2>(Regular Expression Replace\regexprepl_sec)

<p>
The EMACS regular expression replace commands are:

<definition_list>
<deflist_item>(ESC-x re-replace-string)
<x>(re-replace-string)
<deflist_def>
Performs a replace operation using regular expression search and
replacement strings.

<deflist_item>(ESC-x re-query-replace-string)
<x>(re-query-replace-string)
<deflist_def>
Performs a query replace operation using regular expression search and
replacement strings.

<enddefinition_list>

<p>
An extra feature of the <key_name>(re-replace-string) and
<key_name>(re-query-replace-string) commands is the ability to insert
portions of the matched string as part of the replacement.

<p>
In the replacement text, a <quote>(<cx>(&)) character is replaced
by the entire string matched by the search. So, if you
search for <quote>(<cx>(ABC)) and specify a replacement of
<quote>(<cx>(&DEF)), the string inserted into the buffer will be
<quote>(<cx>(ABCDEF)). This facility becomes more useful when a pattern is
searched for and the resulting match is inserted into the
replacement text.

<p>
Regular expression search strings may also be partitioned into a number of
regular-expression substrings using the
<quote>(<cx>(<literal>(\)<oparen>)) and
<quote>(<cx>(<literal>(\)<cparen>)) delimiters.  Each of the strings that
matches one of the subpatterns may be separately inserted into the
replacement text. You specify which match to insert by using
<quote>(<cx>(<literal>(\)n)). <cx>(n) is the position of the
string to insert, starting from the left-hand side in the pattern. The
first bracketed pattern is designated as string 1.  For example, if you
search for
<quote>(<cx>(abc<literal>(\)<oparen>.*<literal>(\)<cparen>ghi<literal>(\)<oparen>.*<literal>(\)<cparen>))
and specify a replacement string of
<quote>(<cx>(<literal>(\)2<literal>(\)1)) and apply these regular
expression to the text <quote>(<cx>(abcdefghijkl)), the replacement text
will be <quote>(<cx>(jkldef)).

<head1>(Abbreviated Input\abbrevinput_sec)

<p>
<newterm>(Abbreviation Mode) allows you to abbreviate text with a
single word. EMACS expands the abbreviation automatically as
soon as you have finished typing the abbreviation.

<p>
Abbreviations are also useful for correcting commonly
misspelled or mis-typed words (abbreviation <quote>(<cx>(thier)) could
expand to <quote>(<cx>(their))), and for upper-casing words like EMACS
(abbreviation <quote>(<cx>(emacs)) could expand to <quote>(<cx>(EMACS))).

<p>
The Abbreviation Mode commands are:

<definition_list>
<deflist_item>(ESC-x define-global-abbrev)
<x>(define-global-abbrev)
<deflist_def>
Defines an abbreviation and expansion and puts them in the
global abbreviation table.

<deflist_item>(ESC-x define-local-abbrev)
<x>(define-local-abbrev)
<deflist_def>
Defines an abbreviation and expansion and puts them in the
current buffer's local abbreviation table.

<deflist_item>(ESC-x read-abbrev-file)
<x>(read-abbrev-file)
<deflist_def>
Reads a file of abbreviations, and merges their definitions
into the existing set of abbreviation tables. Duplicate
entries over-write existing entries in existing
abbreviation tables.

<deflist_item>(ESC-x write-abbrev-file)
<x>(write-abbrev-file)
<deflist_def>
Writes the abbreviations defined by all the abbreviation
tables into a file for later reading.

<deflist_item>(ESC-x use-abbrev-table)
<x>(use-abbrev-table)
<deflist_def>
Associates a named abbreviation table as the current
buffer's local abbreviation table.

<deflist_item>(ESC-x test-abbrev-expand)
<x>(test-abbrev-expand)
<deflist_def>
Checks to see if a string will be expanded, and returns the
expansion for the current buffer.

<enddefinition_list>

<x>(define-local-abbrev)
<x>(define-global-abbrev)
<x>(abbrev-mode)
<p>
To use Abbreviation Mode,  define a global or local abbreviation using
either of the commands <key_name>(ESC-x define-local-abbrev) or
<key_name>(ESC-x define-global-abbrev).  Abbreviation Mode is controlled
by a variable called <key_name>(abbrev-mode). When <key_name>(abbrev-mode)
is non-zero, abbreviations will be expanded. Defining an abbreviation
forces <key_name>(abbrev-mode) to be set.

<p>
In writing this documentation, we could have
defined <quote>(<cx>(am)) to be an abbreviation for <quote>(<cx>(abbrev
mode)). After typing just the letters <quote>(<cx>(am)), we see just
that, <quote>(<cx>(am)); but if we then finish the word by typing
space or period or any other punctuation character, the <quote>(<cx>(am)) is
replaced by and redisplayed as <quote>(<cx>(abbrev mode)). If we
capitalise the abbreviation, <quote>(<cx>(Am)), the expansion is
capitalised: <quote>(<cx>(Abbrev mode)). If we capitalise the whole
abbreviation, <quote>(<cx>(AM)), each word in the expansion is
capitalised: <quote>(<cx>(Abbrev Mode)). In this particular example,
though, we would define <quote>(<cx>(am)) to expand to <quote>(<cx>(Abbrev
Mode)) since it should always to be capitalised that way.
With the <quote>(<cx>(am)) abbreviation defined like this, typing
<quote>(<cx>(In am now)) would produce <quote>(<cx>(In Abbrev Mode
now)).

<p>
Abbreviation Mode does not interfere with the use of major
modes, such as Text, Lisp or Pascal; nor does it interfere with other
minor modes, such as Auto-fill. Each mode may redefine which functions are
bound to characters; this does not affect Abbreviation Mode.

<p>
There are two scopes of abbreviation: <newterm>(local) and
<newterm>(global). A local abbreviation applies only in a buffer which
is associated to the named local abbreviation table, while a
global abbreviation applies in all buffers. If an
abbreviation is defined both as a local abbreviation for the
current buffer and as a global abbreviation, the local
abbreviation expansion takes precedence over the global expansion.

<p>
Abbreviations can be defined one at a time (adding them as you think of
them), or many at a time from an abbreviation file. You can save them in a
file and read them back later.  If you turn off Abbreviation Mode,
abbreviations stop expanding automatically, but their definitions are
remembered in case you turn Abbreviation Mode back on.


<head1>(Keyboard Macros\kbmacro_sec)

<definition_list>
<deflist_item>(^X-<oparen> (start-remembering))
<x>(^X-<oparen>)
<x>(start-remembering)
<deflist_def>
Starts defining a keyboard macro.

<deflist_item>(^X-<cparen> (stop-remembering))
<x>(^X-<cparen>)
<x>(stop-remembering)
<deflist_def>
Ends the definition of a keyboard macro.

<deflist_item>(^X-e (execute-keyboard-macro))
<x>(^X-E)
<x>(execute-keyboard-macro)
<deflist_def>
Executes the most recent keyboard macro.

<enddefinition_list>

<p>
You can define a <newterm>(keyboard macro) to abbreviate a sequence of
other commands.  If you discover that you are about to type
<quote>(<cx>(^U-^D)) forty times, you can define a keyboard macro  to
execute <quote>(<cx>(^U-^D)) and call it with a repeat count of forty.

<p>
Keyboard  macros  differ  from ordinary EMACS commands in that they are
written as keystrokes  rather  than as MLisp code.    This  makes  it easier
for novices to use them.

<p>
You define a keyboard macro while executing the commands  which
are part of  the  definition. In this  way, you can see what the effects of
your commands are---you do not have to work  them  out  in  your
head.  When you have finished, the keyboard macro is defined and has also
been,  in effect, executed once.  You can execute the sequence of commands
again by invoking the macro.

<p>
To start defining a keyboard macro,  type  the  <key_name>(^X-<oparen>)
command.  From then on, your commands continue to be executed,  but  also
become part of the macro definition.  When you have finished, the
<key_name>(^X-<cparen>)  command terminates the definition (without
becoming part of it!).

<p>
The newly-defined  macro  can then  be invoked with the <key_name>(^X-e)
command.  You can give <key_name>(^X-e) a repeat count as a prefix
argument to execute the several times.

<p>
There are two ways of using a keyboard macro to perform some action on
each line in the buffer.  The first is to start by positioning dot on the
line above the first line  to  be  processed, then begin the macro
definition with a <key_name>(^N) (<key_name>(next-line)).  The second
method is to start on the proper line, and end the macro with a
<key_name>(^N). Repeating the macro will operate on successive lines using
either method.
