import os
import sys

_debug = False

def debug( msg ):
    if _debug:
        sys.stderr.write( 'Debug: %s\n' % (msg,) )

class Compiler:
    def __init__( self ):
        debug( 'Compiler.__init__()' )

        self.__variables = {}

        self._addVar( 'PYCXX_VER',       '6.2.0' )
        self._addVar( 'DEBUG',           'NDEBUG')

        self._addFromEnv( 'BUILDER_TOP_DIR' )

    def generateMakefileHeader( self ):
        raise NotImplementedError( 'generateMakefileHeader' )

    def _addFromEnv( self, name ):
        debug( 'Compiler._addFromEnv( %r )' % (name,) )

        self._addVar( name, os.environ[ name ] )

    def _addVar( self, name, value ):
        debug( 'Compiler._addVar( %r, %r )' % (name,value) )

        try:
            if '%' in value:
                value = value % self.__variables

            self.__variables[ name ] = value

        except TypeError:
            raise ValueError( 'Cannot translate name %r value %r' % (name, value) )

    def expand( self, s ):
        try:
            return s % self.__variables

        except TypeError, e:
            print 'Error: %s' % (e,)
            print 'String: %s' % (s,)
            print 'Vairables: %r' % (self.__variables,)

            raise ValueError( 'Cannot translate string (%s)' % (e,) )


class CompilerMSVC90(Compiler):
    def __init__( self ):
        Compiler.__init__( self )

        self._addVar( 'PYCXX',          r'%(BUILDER_TOP_DIR)s\Imports\pycxx-%(PYCXX_VER)s' )
        self._addVar( 'PYCXXSRC',       r'%(BUILDER_TOP_DIR)s\Imports\pycxx-%(PYCXX_VER)s\Src' )
        self._addVar( 'UCDDIR',         r'%(BUILDER_TOP_DIR)s\Imports\ucd' )

        self._addVar( 'PYTHONDIR',      r'c:\python26' )
        self._addVar( 'PYTHON_INCLUDE', r'%(PYTHONDIR)s\include' )
        self._addVar( 'PYTHON_LIB',     r'%(PYTHONDIR)s\libs' )
        self._addVar( 'PYTHON',         r'%(PYTHONDIR)s\python.exe' )

    def getPythonExtensionFileExt( self ):
        return '.pyd'

    def getProgramExt( self ):
        return '.exe'

    def generateMakefileHeader( self ):
        print '#'
        print '#	Bemacs Makefile generated by setup.py'
        print '#'
        print 'CCC=cl /nologo'
        print 'CC=cl /nologo'
        print
        print 'LDSHARED=$(CCC) /LD /Zi /MT /EHsc'
        print 'LDEXE=$(CCC) /Zi /MT /EHsc'
        print

    def ruleLinkProgram( self, target ):
        pyd_filename = target.getTargetFilename()
        pdf_filename = target.getTargetFilename( '.pdf' )

        all_objects = [source.getTargetFilename() for source in target.all_sources]

        rules = ['']

        rules.append( '' )
        rules.append( '%s : %s' % (pyd_filename, ' '.join( all_objects )) )
        rules.append( '\t@echo Link %s' % (pyd_filename,) )
        rules.append( '\t@$(LDEXE)  %%(CCCFLAGS)s /Fe%s /Fd%s %s Advapi32.lib' %
                            (pyd_filename, pdf_filename, ' '.join( all_objects )) )

        print self.expand( '\n'.join( rules ) )

    def ruleLinkShared( self, target ):
        pyd_filename = target.getTargetFilename()
        pdf_filename = target.getTargetFilename( '.pdf' )

        all_objects = [source.getTargetFilename() for source in target.all_sources]

        rules = ['']

        rules.append( '' )
        rules.append( '%s : %s' % (pyd_filename, ' '.join( all_objects )) )
        rules.append( '\t@echo Link %s' % (pyd_filename,) )
        rules.append( '\t@$(LDSHARED)  %%(CCCFLAGS)s /Fe%s /Fd%s %s %%(PYTHON_LIB)s\python26.lib Advapi32.lib' %
                            (pyd_filename, pdf_filename, ' '.join( all_objects )) )

        print self.expand( '\n'.join( rules ) )

    def ruleCxx( self, target ):
        obj_filename = target.getTargetFilename()

        rules = []

        rules.append( '%s: %s %s' % (obj_filename, target.src_filename, ' '.join( target.all_dependencies )) )
        rules.append( '\t@echo Compile: %s into %s' % (target.src_filename, target) )
        rules.append( '\t@$(CCC) /c %%(CCCFLAGS)s /Fo%s /Fd%s %s' % (obj_filename, target.dependent.getTargetFilename( '.pdb' ), target.src_filename) )

        print self.expand( '\n'.join( rules ) )

    def ruleC( self, target ):
        # can reuse the C++ rule
        self.ruleCxx( target )

    def ruleClean( self, filename ):
        rules = []
        rules.append( 'clean::' )
        rules.append( '\tif exist %s del %s' % (filename, filename) )

        print self.expand( '\n'.join( rules ) )

    def setupUtilities( self ):
        self._addVar( 'EDIT_OBJ',   r'win32\obj-utils' )
        self._addVar( 'EDIT_EXE',   r'win32\exe-utils' )
        self._addVar( 'CCCFLAGS',
                                    r'/Zi /MT /EHsc '
                                    r'-IInclude\Common -IInclude\Windows '
                                    r'"-DOS_NAME=\"windows\"" "-DOS_VERSION=\"win32\"" '
                                    r'"-DCPU_TYPE=\"i386\"" "-DUI_TYPE=\"console\"" '
                                    r'-DWIN32=1 -D_CRT_NONSTDC_NO_DEPRECATE '
                                    r'-U_DEBUG '
                                    r'-D%(DEBUG)s' )

    def setupPythonEmacs( self ):
        self._addVar( 'EDIT_OBJ',   r'win32\obj-pybemacs' )
        self._addVar( 'EDIT_EXE',   r'win32\exe-pybemacs' )
        self._addVar( 'CCCFLAGS',
                                    r'/Zi /MT /EHsc '
                                    r'-DPYBEMACS=1 '
                                    r'-IInclude\Common -IInclude\Windows '
                                    r'-DPYCXX_PYTHON_2TO3 -I%(PYCXX)s -I%(PYCXXSRC)s -I%(PYTHON_INCLUDE)s '
                                    r'"-DOS_NAME=\"windows\"" "-DOS_VERSION=\"win32\"" '
                                    r'"-DCPU_TYPE=\"i386\"" "-DUI_TYPE=\"python\"" '
                                    r'-DWIN32=1 -D_CRT_NONSTDC_NO_DEPRECATE '
                                    r'-U_DEBUG '
                                    r'-D%(DEBUG)s' )


class CompilerGCC(Compiler):
    def __init__( self ):
        Compiler.__init__( self )

        self.__type = None

        self._addVar( 'PYCXX',          '%(BUILDER_TOP_DIR)s/Imports/pycxx-%(PYCXX_VER)s' )
        self._addVar( 'PYCXXSRC',       '%(BUILDER_TOP_DIR)s/Imports/pycxx-%(PYCXX_VER)s/Src' )
        self._addVar( 'UCDDIR',         '%(BUILDER_TOP_DIR)s/Imports/ucd' )

        self._addFromEnv( 'PYTHON_VERSION' )
        self._addVar( 'PYTHONDIR',      '/Library/Frameworks/Python.framework/Versions/%(PYTHON_VERSION)s' )
        self._addVar( 'PYTHON_FRAMEWORK', '/Library/Frameworks/Python.framework/Versions/%(PYTHON_VERSION)s/Python' )

        self._addVar( 'PYTHON',         '%(PYTHONDIR)s/Resources/Python.app/Contents/MacOS/Python' )
        self._addVar( 'PYTHON_INCLUDE', '%(PYTHONDIR)s/include/python%(PYTHON_VERSION)s' )

        self._addVar( 'CCC',            'g++ -arch i386' )
        self._addVar( 'CC',             'gcc -arch i386' )

        self._addVar( 'LDEXE',          '%(CCC)s -g' )
        self._addVar( 'LDSHARED',       '%(CCC)s -bundle -g -u _PyMac_Error '
                                        '-framework System '
                                        '%(PYTHON_FRAMEWORK)s '
                                        '-framework CoreFoundation '
                                        '-framework Kerberos '
                                        '-framework Security' )

    def getPythonExtensionFileExt( self ):
        return '.so'

    def getProgramExt( self ):
        return ''

    def generateMakefileHeader( self ):
        print '#'
        print '#	Bemacs Makefile generated by setup.py'
        print '#'
        print

    def ruleLinkProgram( self, target ):
        target_filename = target.getTargetFilename()

        all_objects = [source.getTargetFilename() for source in target.all_sources]

        rules = []

        rules.append( '%s : %s' % (target_filename, ' '.join( all_objects )) )
        rules.append( '\t@echo Link %s' % (target_filename,) )
        rules.append( '\t@%%(LDEXE)s -o %s %%(CCCFLAGS)s %s' % (target_filename, ' '.join( all_objects )) )

        print self.expand( '\n'.join( rules ) )

    def ruleLinkShared( self, target ):
        target_filename = target.getTargetFilename()

        all_objects = [source.getTargetFilename() for source in target.all_sources]

        rules = []

        rules.append( '%s : %s' % (target_filename, ' '.join( all_objects )) )
        rules.append( '\t@echo Link %s' % (target_filename,) )
        rules.append( '\t@%%(LDSHARED)s -o %s %%(CCCFLAGS)s %s' % (target_filename, ' '.join( all_objects )) )

        print self.expand( '\n'.join( rules ) )

    def ruleCxx( self, target ):
        obj_filename = target.getTargetFilename()

        rules = []

        rules.append( '%s: %s %s' % (obj_filename, target.src_filename, ' '.join( target.all_dependencies )) )
        rules.append( '\t@echo Compile: %s into %s' % (target.src_filename, obj_filename) )
        rules.append( '\t@%%(CCC)s -c %%(CCCFLAGS)s -o%s  %s' % (obj_filename, target.src_filename) )

        print self.expand( '\n'.join( rules ) )

    def ruleC( self, target ):
        obj_filename = target.getTargetFilename()

        rules = []

        rules.append( '%s: %s %s' % (obj_filename, target.src_filename, ' '.join( target.all_dependencies )) )
        rules.append( '\t@echo Compile: %s into %s' % (target.src_filename, target) )
        rules.append( '\t@%%(CC)s -c %%(CCCFLAGS)s -o%s  %s' % (obj_filename, target.src_filename) )

        print self.expand( '\n'.join( rules ) )

    def ruleClean( self, filename ):
        rules = []
        rules.append( 'clean::' )
        rules.append( '\trm -f %s' % (filename,) )

        print self.expand( '\n'.join( rules ) )

    def setupUtilities( self ):
        self.__type = 'utils'

        self._addVar( 'EDIT_OBJ',   'darwin/obj-utils' )
        self._addVar( 'EDIT_EXE',   'darwin/exe-utils' )
        self._addVar( 'CCCFLAGS',
                                    '-g  '
                                    '-Wall -fPIC -fexceptions -frtti '
                                    '-IInclude/Common -IInclude/Unix '
                                    '"-DOS_NAME=\\"MacOSX\\"" '
                                    '"-DCPU_TYPE=\\"i386\\"" "-DUI_TYPE=\\"console\\"" '
                                    '-DDARWIN '
                                    '-D%(DEBUG)s' )

    def setupPythonEmacs( self ):
        self.__type = 'pyext'

        self._addVar( 'EDIT_OBJ',   'darwin/obj-pybemacs' )
        self._addVar( 'EDIT_EXE',   'darwin/exe-pybemacs' )
        self._addVar( 'CCCFLAGS',
                                    '-g '
                                    '-Wall -fPIC -fexceptions -frtti '
                                    '-DPYBEMACS=1 '
                                    '-IInclude/Common -IInclude/Unix '
                                    '-DPYCXX_PYTHON_2TO3 -I%(PYCXX)s -I%(PYCXXSRC)s -I%(PYTHON_INCLUDE)s '
                                    '"-DOS_NAME=\\"MacOSX\\"" '
                                    '"-DCPU_TYPE=\\"i386\\"" "-DUI_TYPE=\\"python\\"" '
                                    '-DDARWIN '
                                    '-D%(DEBUG)s' )


class Target:
    def __init__( self, compiler, all_sources ):
        self.compiler = compiler
        self.__generated = False
        self.dependent = None


        self.all_sources = all_sources
        for source in self.all_sources:
            source.setDependent( self )

    def getTargetFilename( self ):
        raise NotImplementedError( '%s.getTargetFilename' % self.__class__.__name__ )

    def generateMakefile( self ):
        if self.__generated:
            return

        self.__generated = True
        return self._generateMakefile()

    def _generateMakefile( self ):
        raise NotImplementedError( '_generateMakefile' )

    def ruleClean( self, ext=None ):
        if ext is None:
            target_filename = self.getTargetFilename()
        else:
            target_filename = self.getTargetFilename( ext )

        self.compiler.ruleClean( target_filename )

    def setDependent( self, dependent ):
        debug( '%r.setDependent( %r )' % (self, dependent,) )
        self.dependent = dependent


class Program(Target):
    def __init__( self, compiler, output, all_sources ):
        self.output = output

        Target.__init__( self, compiler, all_sources )
        debug( 'Program:0x%8.8x.__init__( %r, ... )' % (id(self), output,) )

    def __repr__( self ):
        return '<Program:0x%8.8x %s>' % (id(self), self.output)

    def getTargetFilename( self, ext=None ):
        if ext is None:
            ext = self.compiler.getProgramExt()

        return self.compiler.expand( '%%(EDIT_OBJ)s/%s%s' % (self.output, ext) )


    def _generateMakefile( self ):
        debug( 'Program:0x%8.8x.generateMakefile() for %r dependent %r' % (id(self), self.output, self.dependent) )

        self.compiler.ruleLinkProgram( self )

        # QQQ only good for MSVC90 builds where program.* makes sense
        self.compiler.ruleClean( self.getTargetFilename( '.*' ) )

        for source in self.all_sources:
            source.generateMakefile()


class PythonExtension(Target):
    def __init__( self, compiler, output, all_sources ):
        self.output = output

        Target.__init__( self, compiler, all_sources )
        debug( 'PythonExtension:0x%8.8x.__init__( %r, ... )' % (id(self), output,) )


        for source in self.all_sources:
            source.setDependent( self )

    def __repr__( self ):
        return '<PythonExtension:0x%8.8x %s>' % (id(self), self.output)

    def getTargetFilename( self, ext=None ):
        if ext is None:
            ext = self.compiler.getPythonExtensionFileExt()
        return self.compiler.expand( '%%(EDIT_OBJ)s/%s%s' % (self.output, ext) )


    def _generateMakefile( self ):
        debug( 'PythonExtension:0x%8.8x.generateMakefile() for %r' % (id(self), self.output,) )

        self.compiler.ruleLinkShared( self )
        self.compiler.ruleClean( self.getTargetFilename( '.*' ) )

        for source in self.all_sources:
            source.generateMakefile()


class Source(Target):
    def __init__( self, compiler, src_filename, all_dependencies=None ):
        self.src_filename = compiler.expand( src_filename )

        Target.__init__( self, compiler, [] )

        debug( 'Source:0x%8.8x.__init__( %r, %r )' % (id(self), src_filename, all_dependencies) )

        self.all_dependencies = all_dependencies
        if self.all_dependencies is None:
            self.all_dependencies = []

    def __repr__( self ):
        return '<Source:0x%8.8x %s>' % (id(self), self.src_filename)

    def getTargetFilename( self ):
        if not os.path.exists( self.src_filename ):
            raise ValueError( 'Cannot find source %s' % (self.src_filename,) )

        basename = os.path.basename( self.src_filename )
        if basename.endswith( '.cpp' ):
            return self.compiler.expand( r'%%(EDIT_OBJ)s/%s.obj' % (basename[:-len('.cpp')],) )

        if basename.endswith( '.cxx' ):
            return self.compiler.expand( r'%%(EDIT_OBJ)s/%s.obj' % (basename[:-len('.cxx')],) )

        if basename.endswith( '.c' ):
            return self.compiler.expand( r'%%(EDIT_OBJ)s/%s.obj' % (basename[:-len('.c')],) )

        raise ValueError( 'unknown source %r' % (self.src_filename,) )

    def _generateMakefile( self ):
        debug( 'Source:0x%8.8x.generateMakefile() for %r' % (id(self), self.src_filename,) )

        self.compiler.ruleCxx( self )
        self.compiler.ruleClean( self.getTargetFilename() )

class UnicodeDataHeader(Target):
    def __init__( self, compiler ):
        Target.__init__( self, compiler, [] )

        debug( 'UnicodeDataHeader:0x%8.8x.__init__()' % (id(self),) )

    def __repr__( self ):
        return '<UnicodeDataHeader:0x%8.8x>' % (id(self),)

    def getTargetFilename( self ):
        return 'Include/Common/em_unicode_data.h'

    def generateMakefile( self ):
        rules = ['']

        rules.append( '%s : make_unicode_data.py' % self.getTargetFilename() )
        rules.append( '\t@ echo Info: Make %s' % self.getTargetFilename() )
        rules.append( '\t%%(PYTHON)s make_unicode_data.py %%(UCDDIR)s/UnicodeData.txt %%(UCDDIR)s/CaseFolding.txt %s' % self.getTargetFilename() )

        print self.compiler.expand( '\n'.join( rules ) )
        self.ruleClean()

compiler = CompilerGCC

c_utils = compiler()
c_utils.setupUtilities()

c_pybemacs = compiler()
c_pybemacs.setupPythonEmacs()

unicode_header = UnicodeDataHeader( c_utils )


db_common_files = [
    Source( c_utils, 'Utilities/db_rtl/db_rtl.cpp' ),
    Source( c_utils, 'Source/Common/doprint.cpp' ),
    Source( c_utils, 'Source/Common/em_stat.cpp' ),
    Source( c_utils, 'Source/Common/emstring.cpp' ),
    Source( c_utils, 'Source/Common/emunicode.cpp',
                        ['Include/Common/em_unicode_data.h'] ),
    Source( c_utils, 'Source/Common/file_name_compare.cpp' ),
    Source( c_utils, 'Source/Common/ndbm.cpp' ),
    Source( c_utils, 'Utilities/db_rtl/stub_rtl.cpp' ),
    Source( c_utils, 'Source/Unix/unixfile.cpp' ),
    #Source( c_utils, 'Source/Windows/win_file.cpp' ),
    ]

pycxx_obj_file= [
    Source( c_pybemacs, '%(PYCXXSRC)s/cxxsupport.cxx' ),
    Source( c_pybemacs, '%(PYCXXSRC)s/cxx_extensions.cxx' ),
    Source( c_pybemacs, '%(PYCXXSRC)s/cxxextensions.c' ),
    Source( c_pybemacs, '%(PYCXXSRC)s/IndirectPythonInterface.cxx' ),
    ]

pybemacs_specific_obj_files = [
    Source( c_pybemacs, 'Source/pybemacs/pybemacs.cpp' ),
    Source( c_pybemacs, 'Source/pybemacs/bemacs_python.cpp' ),
    Source( c_pybemacs, 'Source/pybemacs/python_thread_control.cpp' ),
    ] + pycxx_obj_file

obj_files = [
    Source( c_pybemacs, 'Source/Common/abbrev.cpp' ),
    Source( c_pybemacs, 'Source/Common/abspath.cpp' ),
    Source( c_pybemacs, 'Source/Common/arith.cpp' ),
    Source( c_pybemacs, 'Source/Common/buf_man.cpp' ),
    Source( c_pybemacs, 'Source/Common/buffer.cpp' ),
    Source( c_pybemacs, 'Source/Common/caseconv.cpp' ),
    Source( c_pybemacs, 'Source/Common/columns.cpp' ),
    Source( c_pybemacs, 'Source/Common/CommandLine.cpp' ),
    Source( c_pybemacs, 'Source/Common/dbman.cpp' ),
    Source( c_pybemacs, 'Source/Common/display.cpp' ),
    Source( c_pybemacs, 'Source/Common/display_insert_delete.cpp' ),
    Source( c_pybemacs, 'Source/Common/display_line.cpp' ),
    Source( c_pybemacs, 'Source/Common/doprint.cpp' ),
    Source( c_pybemacs, 'Source/Common/em_stat.cpp' ),
    Source( c_pybemacs, 'Source/Common/em_time.cpp' ),
    Source( c_pybemacs, 'Source/Common/emacs.cpp' ),
    Source( c_pybemacs, 'Source/Common/emacs_init.cpp' ),
    Source( c_pybemacs, 'Source/Common/emacs_proc.cpp' ),
    Source( c_pybemacs, 'Source/Common/emacsrtl.cpp' ),
    Source( c_pybemacs, 'Source/Common/emarray.cpp' ),
    Source( c_pybemacs, 'Source/Common/emstring.cpp' ),
    Source( c_pybemacs, 'Source/Common/emunicode.cpp',
            ['Include/Common/em_unicode_data.h'] ),
    Source( c_pybemacs, 'Source/Common/emstrtab.cpp' ),
    Source( c_pybemacs, 'Source/Common/errlog.cpp' ),
    Source( c_pybemacs, 'Source/Common/file_name_compare.cpp' ),
    Source( c_pybemacs, 'Source/Common/fileio.cpp' ),
    Source( c_pybemacs, 'Source/Common/fio.cpp' ),
    Source( c_pybemacs, 'Source/Common/function.cpp' ),
    Source( c_pybemacs, 'Source/Common/getdb.cpp' ),
    Source( c_pybemacs, 'Source/Common/getdirectory.cpp' ),
    Source( c_pybemacs, 'Source/Common/getfile.cpp' ),
    Source( c_pybemacs, 'Source/Common/glob_var.cpp' ),
    Source( c_pybemacs, 'Source/Common/gui_input_mode.cpp' ),
    Source( c_pybemacs, 'Source/Common/journal.cpp' ),
    Source( c_pybemacs, 'Source/Common/key_names.cpp' ),
    Source( c_pybemacs, 'Source/Common/keyboard.cpp' ),
    Source( c_pybemacs, 'Source/Common/lispfunc.cpp' ),
    Source( c_pybemacs, 'Source/Common/macros.cpp' ),
    Source( c_pybemacs, 'Source/Common/mem_man.cpp' ),
    Source( c_pybemacs, 'Source/Common/metacomm.cpp' ),
    Source( c_pybemacs, 'Source/Common/minibuf.cpp' ),
    Source( c_pybemacs, 'Source/Common/mlispars.cpp' ),
    Source( c_pybemacs, 'Source/Common/mlispexp.cpp' ),
    Source( c_pybemacs, 'Source/Common/mlisproc.cpp' ),
    Source( c_pybemacs, 'Source/Common/mlprintf.cpp' ),
    Source( c_pybemacs, 'Source/Common/ndbm.cpp' ),
    Source( c_pybemacs, 'Source/Common/options.cpp' ),
    Source( c_pybemacs, 'Source/Common/queue.cpp' ),
    Source( c_pybemacs, 'Source/Common/save_env.cpp' ),
    Source( c_pybemacs, 'Source/Common/search.cpp' ),
    Source( c_pybemacs, 'Source/Common/search_extended_algorithm.cpp' ),
    Source( c_pybemacs, 'Source/Common/search_extended_parser.cpp' ),
    Source( c_pybemacs, 'Source/Common/search_interface.cpp' ),
    Source( c_pybemacs, 'Source/Common/search_simple_algorithm.cpp' ),
    Source( c_pybemacs, 'Source/Common/search_simple_engine.cpp' ),
    Source( c_pybemacs, 'Source/Common/simpcomm.cpp' ),
    Source( c_pybemacs, 'Source/Common/string_map.cpp' ),
    Source( c_pybemacs, 'Source/Common/subproc.cpp' ),
    Source( c_pybemacs, 'Source/Common/syntax.cpp' ),
    Source( c_pybemacs, 'Source/Common/term.cpp' ),
    Source( c_pybemacs, 'Source/Common/timer.cpp' ),
    Source( c_pybemacs, 'Source/Common/undo.cpp' ),
    Source( c_pybemacs, 'Source/Common/variable.cpp' ),
    Source( c_pybemacs, 'Source/Common/varthunk.cpp' ),
    Source( c_pybemacs, 'Source/Common/windman.cpp' ),
    Source( c_pybemacs, 'Source/Common/window.cpp' ),
    ]

unix_specific_files = [
    Source( c_pybemacs, 'Source/Unix/unix_rtl_pybemacs.cpp' ),
    #Source( c_pybemacs, 'Source/Unix/unix_ext_func.cpp' ),
    Source( c_pybemacs, 'Source/Unix/unixfile.cpp' ),
    ]

win_specific_files = [
    Source( c_pybemacs, 'Source/Windows/win_rtl_pybemacs.cpp' ),
    Source( c_pybemacs, 'Source/Windows/win_file.cpp' ),
    #Source( c_pybemacs, 'Source/Windows/win_ext_func.cpp' ),
    ]

all_exe = [
    PythonExtension( c_pybemacs, '_bemacs', pybemacs_specific_obj_files + obj_files + unix_specific_files ),
    Program( c_utils, 'dbadd',      [Source( c_utils, 'Utilities/dbadd/dbadd.cpp' )]       +db_common_files ),
    Program( c_utils, 'dbcreate',   [Source( c_utils, 'Utilities/dbcreate/dbcreate.cpp' )] +db_common_files ),
    Program( c_utils, 'dbprint',    [Source( c_utils, 'Utilities/dbprint/dbprint.cpp' )]   +db_common_files ),
    Program( c_utils, 'dbdel',      [Source( c_utils, 'Utilities/dbdel/dbdel.cpp' )]       +db_common_files ),
    Program( c_utils, 'dblist',     [Source( c_utils, 'Utilities/dblist/dblist.cpp' )]     +db_common_files ),
    Program( c_utils, 'mll2db',     [Source( c_utils, 'Utilities/mll2db/mll2db.cpp' )]     +db_common_files ),
    ]

def main( argv ):
    try:
        c_pybemacs.generateMakefileHeader()

        print 'all: %s' % (' '.join( [exe.getTargetFilename() for exe in all_exe] ))
        print

        for exe in all_exe:
            exe.generateMakefile()

        unicode_header.generateMakefile()

        return 0

    except ValueError, e:
        sys.stderr.write( 'Error: %s\n' % (e,) )
        return 1

#    except TypeError, e:
#        sys.stderr.write( 'Error: %s\n' % (e,) )
#        return 1

if __name__ == '__main__':
    sys.exit( main( sys.argv ) )
